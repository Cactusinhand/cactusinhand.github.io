<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Design pattern in Gitlay(Git PRC service)</title>
    <url>/posts/341c748.html</url>
    <content><![CDATA[<p>这篇文章源于偶然看到的一篇文章<a href="https://studygolang.com/articles/29501"># Golang技巧之默认值设置的高阶玩法</a>，它讲的是 GRPC 中的设计模式。而我没有研究过 GRPC 源码，看起来稍显陌生。但好在手头上有 Gitaly 源码，算是稍微熟悉它的源码，因此想看看这个项目里面是不是也应用到了前面文章里讲的高阶用法，简单搜索一下源码后，发现这种代码模式还挺多的，于是趁热记录了其中一小段阅读结果。</p>
<span id="more"></span>
<blockquote>
<p>Gitaly is a Git RPC service for handling all the git calls made by GitLab<br>
repo: gitaly: <a href="https://gitlab.com/gitlab-org/gitaly">https://gitlab.com/gitlab-org/gitaly</a></p>
</blockquote>
<p><code>git rev-list</code> 是 Git 中非常重要和有用的命令，它存在许多选项以及子命令，Gitaly 中对这些选项和命令进行了封装。</p>
<p>首先定义了一个 config 结构体，包含不同的配置选项：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ObjectType <span class="token builtin">string</span>

<span class="token keyword">type</span> revlistConfig <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    blobLimit     <span class="token builtin">int</span>
    objects       <span class="token builtin">bool</span>
    objectType    ObjectType
    order         Order
    reverse       <span class="token builtin">bool</span>
    maxParents    <span class="token builtin">uint</span>
    disabledWalk  <span class="token builtin">bool</span>
    firstParent   <span class="token builtin">bool</span>
    before<span class="token punctuation">,</span> after time<span class="token punctuation">.</span>Time
    author        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
    skipResult    <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>RevisionResult<span class="token punctuation">)</span> <span class="token builtin">bool</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后定义一个函数，该函数的参数是上述结构体，且是指针类型参数，这点非常重要，它使得这个函数能够直接修改入参 <code>cfg</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> RevlistOption <span class="token keyword">func</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>revlistConfig<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后是一系列对 git-rev-list 参数进行修改的方法，每个 <code>WithXXX</code> 方法调用前面的匿名函数，并返回 RevlistOption 类型变量：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithBlobLimit</span><span class="token punctuation">(</span>limit <span class="token builtin">int</span><span class="token punctuation">)</span> RevlistOption <span class="token punctuation">&#123;</span>

    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>revlistConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cfg<span class="token punctuation">.</span>blobLimit <span class="token operator">=</span> limit
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithObjectTypeFilter</span><span class="token punctuation">(</span>t ObjectType<span class="token punctuation">)</span> RevlistOption <span class="token punctuation">&#123;</span>

    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>revlistConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cfg<span class="token punctuation">.</span>objectType <span class="token operator">=</span> t
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithRevrse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> RevlistOption <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>revlistConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cfg<span class="token punctuation">.</span>reverse <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithMaxParents</span><span class="token punctuation">(</span>p <span class="token builtin">uint</span><span class="token punctuation">)</span> RevlistOption <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>revlistConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cfg<span class="token punctuation">.</span>maxParents <span class="token operator">=</span> p
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithDisabledWalk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> RevlistOption <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>revlistConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cfg<span class="token punctuation">.</span>disabledWalk <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithFirstParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> RevlistOption <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>revlistConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cfg<span class="token punctuation">.</span>firstParent <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithBefore</span><span class="token punctuation">(</span>t time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> RevlistOption <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>revlistConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cfg<span class="token punctuation">.</span>before <span class="token operator">=</span> t
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithAfter</span><span class="token punctuation">(</span>t time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> RevlistOption <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>revlistConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cfg<span class="token punctuation">.</span>after <span class="token operator">=</span> t
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">WithAuthor</span><span class="token punctuation">(</span>author <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> RevlistOption <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>revlistConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cfg<span class="token punctuation">.</span>author <span class="token operator">=</span> author
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 省略...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>git-rev-list 方法定义如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Revlist</span><span class="token punctuation">(</span>
    ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span>
    repo <span class="token operator">*</span>localrepo<span class="token punctuation">.</span>Repo<span class="token punctuation">,</span>
    revisions <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span>
    options <span class="token operator">...</span>RevlistOption<span class="token punctuation">,</span>
<span class="token punctuation">)</span> RevisionIterator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Revlist() 中最后一个参数 <code>options ...RevlistOption</code>，它表示是不定长变参列表具体参数数量交给调用者。</p>
<p>具体实现如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Revlist</span><span class="token punctuation">(</span>
    ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span>
    repo <span class="token operator">*</span>localrepo<span class="token punctuation">.</span>Repo<span class="token punctuation">,</span>
    revisions <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span>
    options <span class="token operator">...</span>RevlistOption<span class="token punctuation">,</span>
<span class="token punctuation">)</span> RevisionIterator <span class="token punctuation">&#123;</span>
    <span class="token comment">// 定义一个config配置变量</span>
    <span class="token keyword">var</span> cfg revlistConfig

    <span class="token comment">// 注意这里，遍历options中每一个方法，每个方法都会对config变量进行赋值、修改</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> option <span class="token operator">:=</span> <span class="token keyword">range</span> options <span class="token punctuation">&#123;</span>
        <span class="token function">option</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfg<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    resultChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> RevisionResult<span class="token punctuation">)</span>

    <span class="token comment">// 使用goroutine丢到后台运行</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>resultChan<span class="token punctuation">)</span>


        <span class="token comment">// 定义git option变量flags</span>
        flags <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>git<span class="token punctuation">.</span>Option<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

        <span class="token comment">// 下面几项都是根据cfg配置, 更新flag变量</span>
        <span class="token keyword">if</span> cfg<span class="token punctuation">.</span>objects <span class="token punctuation">&#123;</span>
            flags <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span>
                git<span class="token punctuation">.</span>Flag<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"--in-commit-order"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
                git<span class="token punctuation">.</span>Flag<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"--objects"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
                git<span class="token punctuation">.</span>Flag<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"--object-names"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">if</span> cfg<span class="token punctuation">.</span>blobLimit <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            flags <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> git<span class="token punctuation">.</span>Flag<span class="token punctuation">&#123;</span>
                Name<span class="token punctuation">:</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"--filter=blob:limit=%d"</span><span class="token punctuation">,</span> cfg<span class="token punctuation">.</span>blobLimit<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

        <span class="token punctuation">&#125;</span>

        <span class="token keyword">if</span> cfg<span class="token punctuation">.</span>objectType <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>
            flags <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span>
                git<span class="token punctuation">.</span>Flag<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"--filter=object:type=%s"</span><span class="token punctuation">,</span> cfg<span class="token punctuation">.</span>objectType<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
                git<span class="token punctuation">.</span>Flag<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span> <span class="token string">"--filter-provided-objects"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/// 此处省略更多项cfg配置</span>


        <span class="token comment">// 配置完成后，执行git-rev-list命令</span>
        <span class="token keyword">var</span> stderr strings<span class="token punctuation">.</span>Builder
        revlist<span class="token punctuation">,</span> err <span class="token operator">:=</span> repo<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span>
            git<span class="token punctuation">.</span>SubCmd<span class="token punctuation">&#123;</span>
                Name<span class="token punctuation">:</span>  <span class="token string">"rev-list"</span><span class="token punctuation">,</span>
                Flags<span class="token punctuation">:</span> flags<span class="token punctuation">,</span>
                Args<span class="token punctuation">:</span>  revisions<span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            git<span class="token punctuation">.</span><span class="token function">WithStderr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stderr<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span>
        <span class="token comment">// 此处省略错误处理</span>

        <span class="token comment">// 对结果的每行进行处理</span>
        scanner <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewScanner</span><span class="token punctuation">(</span>revlist<span class="token punctuation">)</span>
        <span class="token keyword">for</span> scanner<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            line <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">copy</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> scanner<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

            oidAndName <span class="token operator">:=</span> bytes<span class="token punctuation">.</span><span class="token function">SplitN</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">&#123;</span><span class="token char">' '</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>

            result <span class="token operator">:=</span> RevisionResult<span class="token punctuation">&#123;</span>
                OID<span class="token punctuation">:</span> git<span class="token punctuation">.</span><span class="token function">ObjectID</span><span class="token punctuation">(</span>oidAndName<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">// 省略...</span>
            <span class="token keyword">if</span> isDone <span class="token operator">:=</span> <span class="token function">sendRevisionResult</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> resultChan<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> isDone <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// scan结束</span>
        <span class="token keyword">if</span> err <span class="token operator">:=</span> scanner<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            <span class="token function">sendRevisionResult</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> resultChan<span class="token punctuation">,</span> RevisionResult<span class="token punctuation">&#123;</span>
                err<span class="token punctuation">:</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"scanning rev-list output: %w"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 等待goruntine结束</span>
        <span class="token keyword">if</span> err <span class="token operator">:=</span> revlist<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
            <span class="token function">sendRevisionResult</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> resultChan<span class="token punctuation">,</span> RevisionResult<span class="token punctuation">&#123;</span>
                err<span class="token punctuation">:</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"rev-list pipeline command: %w, stderr: %q"</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> stderr<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 返回结果</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>revisionIterator<span class="token punctuation">&#123;</span>
        ch<span class="token punctuation">:</span> resultChan<span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么如何调用这个方法呢？搜索 Gitaly 源码可以看到：</p>
<p>在<code>ListBlobs</code> 中是这样用的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>server<span class="token punctuation">)</span> <span class="token function">ListBlobs</span><span class="token punctuation">(</span>req <span class="token operator">*</span>gitalypb<span class="token punctuation">.</span>ListBlobsRequest<span class="token punctuation">,</span> stream gitalypb<span class="token punctuation">.</span>BlobService_ListBlobsServer<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 省略...</span>

    <span class="token comment">// 定义一个RevlistOption变量，向里面注入多个配置选项</span>
    revlistOptions <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>gitpipe<span class="token punctuation">.</span>RevlistOption<span class="token punctuation">&#123;</span>
        gitpipe<span class="token punctuation">.</span><span class="token function">WithObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        gitpipe<span class="token punctuation">.</span><span class="token function">WithObjectTypeFilter</span><span class="token punctuation">(</span>gitpipe<span class="token punctuation">.</span>ObjectTypeBlob<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 调用Revlist()</span>
    revlistIter <span class="token operator">:=</span> gitpipe<span class="token punctuation">.</span><span class="token function">Revlist</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> repo<span class="token punctuation">,</span> req<span class="token punctuation">.</span><span class="token function">GetRevisions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> revlistOptions<span class="token operator">...</span><span class="token punctuation">)</span>

    <span class="token comment">// 省略...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ListCommits</code> 中根据请求中不同的 case 分别向 revlistOptions 变量追加不同的配置选项：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>server<span class="token punctuation">)</span> <span class="token function">ListCommits</span><span class="token punctuation">(</span>
    request <span class="token operator">*</span>gitalypb<span class="token punctuation">.</span>ListCommitsRequest<span class="token punctuation">,</span>
    stream gitalypb<span class="token punctuation">.</span>CommitService_ListCommitsServer<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 省略...</span>
    ctx <span class="token operator">:=</span> stream<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    repo <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">localrepo</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">GetRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">// 定义一个revlistOptions变量</span>
    revlistOptions <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>gitpipe<span class="token punctuation">.</span>RevlistOption<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token comment">// 省略...</span>

    <span class="token comment">/// 根据不同的case向revlistOptions追加不同的配置</span>
    <span class="token keyword">if</span> request<span class="token punctuation">.</span><span class="token function">GetReverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        revlistOptions <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>revlistOptions<span class="token punctuation">,</span> gitpipe<span class="token punctuation">.</span><span class="token function">WithReverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> request<span class="token punctuation">.</span><span class="token function">GetMaxParents</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        revlistOptions <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>revlistOptions<span class="token punctuation">,</span> gitpipe<span class="token punctuation">.</span><span class="token function">WithMaxParents</span><span class="token punctuation">(</span><span class="token function">uint</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">GetMaxParents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> request<span class="token punctuation">.</span><span class="token function">GetDisableWalk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        revlistOptions <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>revlistOptions<span class="token punctuation">,</span> gitpipe<span class="token punctuation">.</span><span class="token function">WithDisabledWalk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> request<span class="token punctuation">.</span><span class="token function">GetFirstParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        revlistOptions <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>revlistOptions<span class="token punctuation">,</span> gitpipe<span class="token punctuation">.</span><span class="token function">WithFirstParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> request<span class="token punctuation">.</span><span class="token function">GetBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        revlistOptions <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>revlistOptions<span class="token punctuation">,</span> gitpipe<span class="token punctuation">.</span><span class="token function">WithBefore</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">GetBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AsTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> request<span class="token punctuation">.</span><span class="token function">GetAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        revlistOptions <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>revlistOptions<span class="token punctuation">,</span> gitpipe<span class="token punctuation">.</span><span class="token function">WithAfter</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">GetAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AsTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">GetAuthor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        revlistOptions <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>revlistOptions<span class="token punctuation">,</span> gitpipe<span class="token punctuation">.</span><span class="token function">WithAuthor</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">GetAuthor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

   <span class="token comment">// 调用Revlist()</span>
    revlistIter <span class="token operator">:=</span> gitpipe<span class="token punctuation">.</span><span class="token function">Revlist</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> repo<span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">GetRevisions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> revlistOptions<span class="token operator">...</span><span class="token punctuation">)</span>

    <span class="token comment">// 省略后续...</span>

    <span class="token keyword">return</span> <span class="token boolean">nil</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ListLFSPointers</code> 中省略定义 RevlistOption 变量，直接利用 Revlist 方法中不定参数特性，添加不同的配置选项：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>server<span class="token punctuation">)</span> <span class="token function">ListLFSPointers</span><span class="token punctuation">(</span>in <span class="token operator">*</span>gitalypb<span class="token punctuation">.</span>ListLFSPointersRequest<span class="token punctuation">,</span> stream gitalypb<span class="token punctuation">.</span>BlobService_ListLFSPointersServer<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
    ctx <span class="token operator">:=</span> stream<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 省略...</span>
    repo <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">localrepo</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">GetRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 省略...</span>

    <span class="token comment">// 调用Revlist()</span>
    revlistIter <span class="token operator">:=</span> gitpipe<span class="token punctuation">.</span><span class="token function">Revlist</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> repo<span class="token punctuation">,</span> in<span class="token punctuation">.</span><span class="token function">GetRevisions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        gitpipe<span class="token punctuation">.</span><span class="token function">WithObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        gitpipe<span class="token punctuation">.</span><span class="token function">WithBlobLimit</span><span class="token punctuation">(</span>lfsPointerMaxSize<span class="token punctuation">)</span><span class="token punctuation">,</span>
        gitpipe<span class="token punctuation">.</span><span class="token function">WithObjectTypeFilter</span><span class="token punctuation">(</span>gitpipe<span class="token punctuation">.</span>ObjectTypeBlob<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
    <span class="token comment">/// 省略后续...</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总结：</p>
<p>这种设计模式对于多配置，多参数的方法非常适合，虽然代码实现起来有点麻烦，但是可读性强，使用灵活。这种模式还有一些变体，后面有时间再记录一下。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Design-Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>GitOps: 一种 DevOps 的最佳实践</title>
    <url>/posts/f8df64f6.html</url>
    <content><![CDATA[<blockquote>
<p><strong>本文转载于：<a href="https://icloudnative.io/posts/what-is-gitops/">https://icloudnative.io/posts/what-is-gitops/</a></strong><br>
<strong>作者: 米开朗基杨</strong></p>
</blockquote>
<p>GitOps 这个概念最早是由 Kubernetes 管理公司 Weaveworks 公司在 2017 年提出的，如今已经过去了 5 个年头，想必大家对这个概念早有耳闻，但你可能并不知道它到底是什么，它和 DevOps 到底是啥关系，本文就来帮大家一一解惑。</p>
<h2 id="基础设施即代码">基础设施即代码</h2>
<p>在理解 GitOps 之前，我们需要先理解什么是<strong>基础设施即代码</strong>。</p>
<p>基础设施即代码（Infrastructure as Code, <strong>IaC</strong>），顾名思义，表示使用代码（而非手动流程）来定义基础设施，研发人员可以像对待应用软件一样对待基础设施，例如：</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>可以创建包含基础架构规范的声明式配置文件，从而便于编辑和分发配置。</p>
</li>
<li class="lvl-4">
<p>可以确保每次配置的环境都完全相同。</p>
</li>
<li class="lvl-4">
<p>可以进行版本控制，所有的变更都会被记录下来，方便溯源。</p>
</li>
<li class="lvl-4">
<p>可以将基础设施划分为若干个模块化组件，并通过自动化以不同的方式进行组合。</p>
</li>
</ul>
<p>当然，广义上的 IaC 不仅仅只关于基础设施，还包含了<strong>网络</strong>、<strong>安全</strong>、<strong>配置</strong>等等，所以广义上的 IaC 又叫 <strong>X as Code</strong>。<br>
<img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/20220906161123.png" alt=""></p>
<p>比如你想在 AWS 中创建服务器，配置网络，部署 Kubernetes 集群以及各种工作负载，你只需要定义好 Terraform 或 Ansible 的声明式配置，以及 Kubernetes 的配置清单即可，免去一切繁杂的手动操作。</p>
<h2 id="GitOps-是什么">GitOps 是什么</h2>
<p>GitOps = IaC + Git + CI/CD，即基于 IaC 的版本化 CI/CD。它的核心是使用 Git 仓库来管理基础设施和应用的配置，并且<strong>以 Git 仓库作为基础设施和应用的单一事实来源</strong>，你从其他地方修改配置（比如手动改线上配置）一概不予通过。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/20220906161321.png" alt=""></p>
<p>Git 仓库中的声明式配置描述了目标环境当前所需基础设施的期望状态，借助于 GitOps，如果集群的实际状态与 Git 仓库中定义的期望状态不匹配，Kubernetes reconcilers 会根据期望状态来调整当前的状态，最终使实际状态符合期望状态。</p>
<p>另一方面，现代应用的开发更多关注的是迭代速度和规模，拥有成熟 DevOps 文化的组织每天可以将代码部署到生成环境中数百次，DevOps 团队可以通过版本控制、代码审查以及自动测试和部署的 CI/CD 流水线等最佳实践来实现这一目标，这就是 GitOps 干的事情。</p>
<h2 id="GitOps-vs-DevOps">GitOps vs DevOps</h2>
<p>从广义上来看，GitOps 与 DevOps 并不冲突，<strong>GitOps 是一种技术手段，而 DevOps 是一种文化</strong>。GitOps 是一种实现持续交付（Continuous Delivery）、持续部署（Continuous Deployment）和基础设施即代码（IaC）的工具和框架，它是支持 DevOps 文化的。</p>
<p>从狭义上来看，GitOps 与 DevOps 有以下几个区别：</p>
<p>首先，<strong>GitOps 是以目标为导向的</strong>。它使用 Git 来维护期望状态，并不断调整实际状态，最终与期望状态相匹配。而 <strong>DevOps 更多关注的是最佳实践</strong>，这些实践可以普遍应用于企业的每一个流程。</p>
<p>其次，<strong>GitOps 采取声明式的操作方法，而 DevOps 同时接受声明式和命令式的方法</strong>，所以 DevOps 除了适用于容器环境之外，还适用于虚拟机和裸机环境。</p>
<p>最后，<strong>GitOps 重新定义了云原生场景下的 CI/CD</strong>，它以 Git 作为中心的不可变状态声明，以加快持续部署速度。</p>
<h2 id="GitOps-的设计哲学">GitOps 的设计哲学</h2>
<p>想要使用 GitOps 来管理你的基础设施和应用，需要践行以下几个原则：</p>
<h3 id="1-声明式">1. 声明式</h3>
<p>必须通过声明式来描述系统的期望状态。例如 Kubernetes，众多现代云原生工具都是声明式的，Kubernetes 只是其中的一种。</p>
<h3 id="2-版本控制-不可变">2. 版本控制/不可变</h3>
<p>因为所有的状态声明都存储在 Git 仓库中，并且把 Git 仓库作为单一事实来源，那么所有的操作都是从 Git 仓库里驱动的，而且保留了完整的版本历史，方便回滚。有了 Git 优秀的安全保障，也可以使用 SSH 密钥来签署 commits，对代码的作者和出处实施强有力的安全保障。</p>
<h3 id="3-自动应用变更">3. 自动应用变更</h3>
<p>Git 仓库中声明的期望状态发生了任何变更，都可以立即应用到系统中，而且不需要安装配置额外工具（比如 kubectl），也不需要配置 Kubernetes 的认证授权。</p>
<h3 id="4-持续的-Reconciliation">4. 持续的 Reconciliation</h3>
<p>Reconciliation 其实最早是 Kubernetes 里的一个概念，表示的是<strong>确保系统的实际状态与期望状态一致的过程</strong>。具体的实现方式是在目标环境中安装一个 agent，一旦实际状态与期望状态不匹配，agent 就会进行自动修复。这里的修复比 Kubernetes 的故障自愈更高级，即使是手动修改了集群的编排清单，集群也会被恢复到 Git 仓库中的清单所描述的状态。</p>
<p>鉴于以上这些设计哲学，我们来看一下 GitOps 的工作流：<br>
<img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/20220906161329.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>首先，团队中的任何一个成员都可以 Fork 仓库对配置进行更改，然后提交 Pull Request。</p>
</li>
<li class="lvl-4">
<p>接下来会运行 CI 流水线，一般会做这么几件事情：验证配置文件、执行自动化测试、检测代码的复杂性、构建 OCI 镜像、将镜像推送到镜像仓库等等。</p>
</li>
<li class="lvl-4">
<p>CI 流水线运行完成后，团队中拥有合并代码权限的人将会将这个 Pull Request 合并到主分支中 。一般拥有这个权限的都是研发人员、安全专家或者高级运维工程师。</p>
</li>
<li class="lvl-4">
<p>最后会运行 CD 流水线，将变更应用到目标系统中（比如 Kubernetes 集群或者 AWS） 。</p>
</li>
</ul>
<p>整个过程完全自动化且透明，通过多人协作和自动化测试来保证了基础设施声明配置的健壮性。而传统的模式是其中一个工程师在自己的电脑上操作这一切，其他人不知道发生了什么，也无法对其操作进行 Review。</p>
<h2 id="Push-vs-Pull">Push vs Pull</h2>
<p>CD 流水线有两种模式：Push 和 Pull。</p>
<h3 id="Push-模式">Push 模式</h3>
<p>目前大多数 CI/CD 工具都使用基于 Push 的部署模式，例如 Jenkins、CircleCI 等。这种模式一般都会在 CI 流水线运行完成后执行一个命令（比如 kubectl）将应用部署到目标环境中。<br>
<img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/20220906161346.png" alt=""></p>
<p>这种 CD 模式的缺陷很明显：</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>需要安装配置额外工具（比如 kubectl）；</p>
</li>
<li class="lvl-4">
<p>需要 Kubernetes 对其进行授权；</p>
</li>
<li class="lvl-4">
<p>需要云平台授权；</p>
</li>
<li class="lvl-4">
<p>无法感知部署状态。也就无法感知期望状态与实际状态的偏差，需要借助额外的方案来保障一致性。</p>
</li>
</ul>
<p>Kubernetes 集群或者云平台对 CI 系统的授权凭证在集群或云平台的信任域之外，不受集群或云平台的安全策略保护，因此 CI 系统很容易被当成非法攻击的载体。</p>
<h3 id="Pull-模式">Pull 模式</h3>
<p>Pull 模式会在目标环境中安装一个 Agent，例如在 Kubernetes 集群中就靠 Operator 来充当这个 Agent。Operator 会周期性地监控目标环境的实际状态，并与 Git 仓库中的期望状态进行比较，如果实际状态不符合期望状态，Operator 就会更新基础设施的实际状态以匹配期望状态。<br>
<img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/20220906161356.png" alt=""></p>
<p>只有 Git 的变更可以作为期望状态的唯一来源，除此之外，任何人都不可以对集群进行任何更改，即使你修改了，也会被 Operator 还原为期望状态，这也就是传说中的<strong>不可变基础设施</strong>。</p>
<p>目前基于 Pull 模式的 CD 工具有 <a href="https://github.com/argoproj/argo-cd/">Argo CD</a>， <a href="https://github.com/fluxcd/flux">Flux CD</a> 以及 <a href="https://github.com/kubesphere/ks-devops">ks-devops</a>。</p>
<h2 id="GitOps-的优势">GitOps 的优势</h2>
<p>一般 GitOps 首选的都是基于 Pull 的部署模式，因为这种模式有很多不可替代的优势。</p>
<h3 id="更强大的安全保障">更强大的安全保障</h3>
<p>上面已经提到了，使用 GitOps 不需要任何 Kubernetes 或者云平台的凭证来执行部署，Kubernetes 集群内的 Argo CD 或者 Flux CD 只需要访问 Git 仓库，并通过 Pull 模式来更新即可。</p>
<p>另一方面，Git 由用于跟踪和管理代码变更的强大密码学支持，拥有对变更进行签名以证明作者身份和来源的能力，这是保障集群安全的关键。</p>
<h3 id="Git-作为事实的唯一真实来源">Git 作为事实的唯一真实来源</h3>
<p>因为所有的应用包括基础设施的声明式配置都保存在 Git 中，并把 Git 作为应用系统的唯一事实来源，因此可以利用 Git 的强大功能操作所有东西，例如版本控制、历史记录、审计和回滚等等，无需使用 kubectl 这样的工具来操作。</p>
<h3 id="提高生产力">提高生产力</h3>
<p>Git 也是开发人员非常熟悉的工具，通过 Git 不断迭代，可以提高生产率，加快开发和部署速度，更快地推出新产品，同时提高系统的稳定性和可靠性。</p>
<h3 id="更容易合规的审计">更容易合规的审计</h3>
<p>使用 GitOps 的基础设施可以像任何软件项目一样使用 Git 来管理，所以同样可以对其进行质量审计。当有人需要对基础设施进行更改时，会创建一个 Pull Request，等相关人员对其进行 Code Review 之后，更改才可以应用到系统中。</p>
<h2 id="总结">总结</h2>
<p>GitOps 是对现有 DevOps 文化的补充，它使用 Git 这样的版本控制系统来自动部署基础设施，部署过程清晰可见，可以查看和跟踪对系统进行的任何变更，提高了生产力、安全性和合规性。而且 GitOps 提供了更优雅的可观测性，可以实时观测部署状态，并采取行动使实际状态与期望状态保持一致。</p>
<p>而且在 GitOps 中，整个系统都是通过声明式来描述的，天然适合云原生环境，因为 Kubernetes 也是这么设计的。</p>
<h2 id="参考资料">参考资料</h2>
<ul class="lvl-0">
<li class="lvl-4">
<p><a href="https://devs-group.medium.com/what-is-gitops-and-what-should-you-know-about-it-fcaa3e3c1dd5">What is GitOps and what should you know about it?</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.tynybay.com/our-thinking/devops-vs-gitops-4-benefits-you-must-know-to-master-the-methodologies">DevOps vs GitOps: 4 Benefits you must know to Master the Methodologies</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.weave.works/technologies/gitops/">Guide To GitOps</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitOps</tag>
        <tag>DevOps</tag>
        <tag>Workflow</tag>
      </tags>
  </entry>
  <entry>
    <title>如何向 Git 社区提交代码(2)</title>
    <url>/posts/23bf24d1.html</url>
    <content><![CDATA[<h3 id="背景">背景</h3>
<p>第一次向 Git 社区提交代码起源于 Gitee 的一个需求。Gitee 创建新仓库有多种方式，其中一种是根据用户提供的仓库 URL 导入新仓库，Gitee 首先会对用户提供的 URL 进行校验，只有合格的仓库地址才会生成新仓库。但是有种情况比较特别，若用户确实提供了一个合法的 Git 仓库地址，但是这个仓库不是完整的，常见的情况就是浅仓库(shallow repo)，这类仓库缺乏足够的历史提交信息，因此会带来一些问题。为了避免这种情况，在服务端就需要对用户导入的仓库进行特别处理。在服务端，导入仓库的动作本质上就是执行 <code>git clone --mirror</code> 命令，那么有没有可能在执行这个克隆命令的过程中就对仓库进行判断呢？如果能，这将避免克隆完整个仓库再进行判断仓库是否为浅仓库，这样无疑更有效。于是我开始研究 Git 源码，琢磨如何给 <code>git-clone</code> 命令赋予一项新的能力。</p>
<p>按照前面的方法向 Git 社区提交了第一版代码：<a href="https://public-inbox.org/git/pull.865.git.1612409491842.gitgitgadget@gmail.com/#t">v1</a></p>
<p>很快收到 <strong><a href="https://public-inbox.org/git/xmqq35yc9yan.fsf@gitster.c.googlers.com/#t">Junio C Hamano</a></strong> 反馈，主要问题有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>commit 信息中说明不清，英文语法错误：</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&gt; This patch add a new option that reject to clone a shallow repository.

A canonical form of our log message starts by explaining the need,
and then presents the solution at the end.
一条规范的 commit 信息格式应该是在开始就解释更改需求，然后在结尾提供解决方案。

&gt; Clients don&#39;t know it&#39;s a shallow repository until they download it
&gt; locally, in some scenariors, clients just don&#39;t want to clone this kind

&quot;scenarios&quot;.  &quot;in some scenarios&quot; would have to be clarified a bit
more to justify why it is a good idea to have such a feature.
这里的需求场景描述地不够有说服力。

&gt; of repository, and want to exit the process immediately without creating
&gt; any unnecessary files.

&quot;clients don&#39;t know it&#39;s a shallow repository until they download&quot;
leading to &quot;so let&#39;s reject immediately upon finding out that they
are shallow&quot; does make sense as a flow of thought, though.
这里表述不够清晰，Junio 顺便提供了他的建议
&gt; +--no-shallow::
&gt; +	Don&#39;t clone a shallow source repository. In some scenariors, clients

&quot;scenarios&quot; (no &#39;r&#39;).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul class="lvl-0">
<li class="lvl-2">
<p>新增选项 <code>--no-shallow</code> 不对，应该考虑到布尔类选项存在反选情况，即 <code>--no-no-shallow</code> ，因此不应该这么写，建议改为 <code>--reject-shallow</code>， 它的反选即为 <code>--no-reject-shallow</code>，这样语义上也更符合直觉：</p>
</li>
</ul>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> diff --git a/builtin/clone.c b/builtin/clone.c
</span></span>
<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> @@ -90,6 +91,7 @@ static struct option builtin_clone_options[] = &#123;
</span><span class="token prefix inserted">></span><span class="token line">  	OPT__VERBOSITY(&amp;option_verbosity),
</span><span class="token prefix inserted">></span><span class="token line">  	OPT_BOOL(0, "progress", &amp;option_progress,
</span><span class="token prefix inserted">></span><span class="token line">  		 N_("force progress reporting")),
</span><span class="token prefix inserted">></span><span class="token line"> +	OPT_BOOL(0, "no-shallow", &amp;option_no_shallow, N_("don't clone shallow repository")),
</span><span class="token prefix inserted">></span><span class="token line">  	OPT_BOOL('n', "no-checkout", &amp;option_no_checkout,
</span><span class="token prefix inserted">></span><span class="token line">  		 N_("don't create a checkout")),
</span><span class="token prefix inserted">></span><span class="token line">  	OPT_BOOL(0, "bare", &amp;option_bare, N_("create a bare repository")),
</span></span>
It is a bad idea to give a name that begins with "no-" to an option
whose default can be tweaked by a configuration variable [*].  If
the configuration is named "rejectshallow", perhaps it is better to
call it "--reject-shallow" instead.

This is because configured default must be overridable from the
command line.  I.e. even if you have in your ~/.gitconfig this:

<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   [clone]
</span><span class="token prefix unchanged"> </span><span class="token line">       rejectshallow = true
</span></span>
you should be able to say "allow it only this time", with

<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   $ git clone --no-reject-shallow http://github.com/git/git/ git
</span></span>
and you do not want to have to say "--no-no-shallow", which sounds
just silly.

	Side note. it is a bad idea in general, even if the option
	does not have corresponding configuration variable.  The
	existing "no-checkout" is a historical accident that
	happened long time ago and cannot be removed due to
	compatibility.  Let's not introduce a new option that
	follows such a bad pattern.

	Junio 进一步解释：现存的选项 `no-checkout` 是一个很久之前的历史错误，
	由于兼容性，已经无法移除这个错误了，现在新的选项不应该按照这种模式命名。
	P.S. 刚好我就是按照`no-checkout`选项的模式创造出`no-shllow`选项的-:)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>更重要的是，<strong>命令行优先于配置</strong>，即命令行选项要能够覆盖配置文件选项。当配置文件从全局上不允许克隆 shllow 仓库时，而用户想要允许单次克隆 shallow 仓库时，自然地，他会使用 <code>--no-shallow</code> 选项的反选项 <code>--no-no-shallow</code> 来覆盖掉配置中的选项 。但这样 <code>--no-no-shallow</code> 听来去就很傻。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于 Git 存在多种传输协议，目前的修改只是解决了本地克隆问题，因此仍需改进：</p>
</li>
</ul>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> @@ -963,6 +968,7 @@ static int path_exists(const char *path)
</span><span class="token prefix inserted">></span><span class="token line">  int cmd_clone(int argc, const char **argv, const char *prefix)
</span><span class="token prefix inserted">></span><span class="token line">  &#123;
</span><span class="token prefix inserted">></span><span class="token line">  	int is_bundle = 0, is_local;
</span><span class="token prefix inserted">></span><span class="token line"> +	int is_shallow = 0;
</span><span class="token prefix inserted">></span><span class="token line">  	const char *repo_name, *repo, *work_tree, *git_dir;
</span><span class="token prefix inserted">></span><span class="token line">  	char *path, *dir, *display_repo = NULL;
</span><span class="token prefix inserted">></span><span class="token line">  	int dest_exists, real_dest_exists = 0;
</span><span class="token prefix inserted">></span><span class="token line"> @@ -1215,6 +1221,7 @@ int cmd_clone(int argc, const char **argv, const char *prefix)
</span><span class="token prefix inserted">></span><span class="token line">  		if (filter_options.choice)
</span><span class="token prefix inserted">></span><span class="token line">  			warning(_("--filter is ignored in local clones; use file:// instead."));
</span><span class="token prefix inserted">></span><span class="token line">  		if (!access(mkpath("%s/shallow", path), F_OK)) &#123;
</span><span class="token prefix inserted">></span><span class="token line"> +			is_shallow = 1;
</span><span class="token prefix inserted">></span><span class="token line">  			if (option_local > 0)
</span><span class="token prefix inserted">></span><span class="token line">  				warning(_("source repository is shallow, ignoring --local"));
</span><span class="token prefix inserted">></span><span class="token line">  			is_local = 0;
</span></span>
This change is to the local clone codepath.  Cloning over the wire
would not go through this part.  And throughout the patch, this is
the only place that sets is_shallow to 1.

Also let's note that this is after we called parse_options(), so the
value of option_no_shallow is known at this point.

So, this patch does not even *need* to introduce a new "is_shallow"
variable at all.  It only needs to add

<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                       if (option_no_shallow)
</span><span class="token prefix unchanged"> </span><span class="token line">                               die(...);
</span></span>
instead of adding "is_shallow = 1" to the above hunk.

I somehow think that this is only half a feature---wouldn't it be
more useful if we also rejected a non-local clone from a shallow
repository?
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul class="lvl-0">
<li class="lvl-2">
<p>测试代码中的问题：</p>
</li>
</ul>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">And for that ...

<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> diff --git a/t/t5606-clone-options.sh b/t/t5606-clone-options.sh
</span><span class="token prefix inserted">></span><span class="token line"> index 7f082fb23b6a..9d310dbb158a 100755
</span><span class="token prefix inserted">></span><span class="token line"> --- a/t/t5606-clone-options.sh
</span><span class="token prefix inserted">></span><span class="token line"> +++ b/t/t5606-clone-options.sh
</span><span class="token prefix inserted">></span><span class="token line"> @@ -42,6 +42,13 @@ test_expect_success 'disallows --bare with --separate-git-dir' '
</span><span class="token prefix inserted">></span><span class="token line">  
</span><span class="token prefix inserted">></span><span class="token line">  '
</span><span class="token prefix inserted">></span><span class="token line">  
</span><span class="token prefix inserted">></span><span class="token line"> +test_expect_success 'reject clone shallow repository' '
</span><span class="token prefix inserted">></span><span class="token line"> +	git clone --depth=1 --no-local parent shallow-repo &amp;&amp;
</span><span class="token prefix inserted">></span><span class="token line"> +	test_must_fail git clone --no-shallow shallow-repo out 2>err &amp;&amp;
</span><span class="token prefix inserted">></span><span class="token line"> +	test_i18ngrep -e "source repository is shallow, reject to clone." err
</span><span class="token prefix inserted">></span><span class="token line"> +
</span><span class="token prefix inserted">></span><span class="token line"> +'
</span><span class="token prefix inserted">></span><span class="token line"> +
</span></span>
... in addition to the test for a local clone above, you'd also want
to test a non-local clone, perhaps like so:

test_expect_success 'reject clone shallow repository' '
	rm -fr shallow-repo &amp;&amp;
	git clone --depth=1 --no-local parent shallow-repo &amp;&amp;
	test_must_fail git clone --no-shallow --no-local shallow-repo out 2>err &amp;&amp;
	test_i18ngrep -e "source repository is shallow, reject to clone." err

'

Ditto for the other test script.

Also, you would want to make sure that the command line overrides
the configured default.  I.e.

	git -c clone.rejectshallow=false clone --reject-shallow

should refuse to clone from a shallow one, while there should be a
way to countermand a configured "I always refuse to clone from a
shallow repository" with "but let's allow it only this time", i.e.

	git -c clone.rejectshallow=true clone --no-reject-shallow

or something along the line.


<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> diff --git a/t/t5611-clone-config.sh b/t/t5611-clone-config.sh
</span><span class="token prefix inserted">></span><span class="token line"> index 8e0fd398236b..3aab86ad4def 100755
</span><span class="token prefix inserted">></span><span class="token line"> --- a/t/t5611-clone-config.sh
</span><span class="token prefix inserted">></span><span class="token line"> +++ b/t/t5611-clone-config.sh
</span><span class="token prefix inserted">></span><span class="token line"> @@ -92,6 +92,13 @@ test_expect_success 'clone -c remote.&lt;remote>.fetch=&lt;refspec> --origin=&lt;name>' '
</span><span class="token prefix inserted">></span><span class="token line">  	test_cmp expect actual
</span><span class="token prefix inserted">></span><span class="token line">  '
</span><span class="token prefix inserted">></span><span class="token line">  
</span><span class="token prefix inserted">></span><span class="token line"> +test_expect_success 'clone -c clone.rejectshallow' '
</span><span class="token prefix inserted">></span><span class="token line"> +	rm -rf child &amp;&amp;
</span><span class="token prefix inserted">></span><span class="token line"> +	git clone --depth=1 --no-local . child &amp;&amp;
</span><span class="token prefix inserted">></span><span class="token line"> +	test_must_fail git clone -c clone.rejectshallow child out 2>err &amp;&amp;
</span></span>
This is not quite right, even though it may happen to work.  The
"clone.rejectshallow" variable is a configuration about what should
happen when creating a new repository by cloning, so letting "git
clone -c var[=val]" to set the variable _in_ the resulting repository
would not make much sense.  Even if the clone succeeded, nobody would
look at that particular configuration variable that is set in the
resulting repository.

I think it would communicate to the readers better what we are
trying to do, if we write

	test_must_fail git -c clone.rejectshallow=true clone child out

instead.

Thanks.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过测试代码 Junio 指出： <code>clone.rejectshallow</code> 配置和命令行选项 <code>--reject-shallow</code> 存在逻辑上的交叉重叠问题，因此测试时应该体现出这一点。</p>
<p>以上就是我第一次提交的代码，没想到能很快收到那么多宝贵的检视建议。但是，这只是开始，后面还有更多的检视回合，收到了更加细致的检视意见。</p>
<p>比如 <a href="https://public-inbox.org/git/nycvar.QRO.7.76.6.2103311146210.52@tvgsbejvaqbjf.bet/">Johannes Schindelin</a> 给了一些意见：</p>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">我觉得这个补丁大部分都很好，但我还有一点点改进建议
I like most of the patch, and will only point out a couple of things that
I think can be improved even further.

<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> diff --git a/Documentation/git-clone.txt b/Documentation/git-clone.txt
</span><span class="token prefix inserted">></span><span class="token line"> index 02d9c19cec75..0adc98fa7eee 100644
</span><span class="token prefix inserted">></span><span class="token line"> --- a/Documentation/git-clone.txt
</span><span class="token prefix inserted">></span><span class="token line"> +++ b/Documentation/git-clone.txt
</span><span class="token prefix inserted">></span><span class="token line"> @@ -149,6 +149,11 @@ objects from the source repository into a pack in t=
</span></span>he cloned repository.
<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line">  --no-checkout::
</span><span class="token prefix inserted">></span><span class="token line">  	No checkout of HEAD is performed after the clone is complete.
</span><span class="token prefix inserted">></span><span class="token line">
</span><span class="token prefix inserted">></span><span class="token line"> +--[no-]reject-shallow::
</span><span class="token prefix inserted">></span><span class="token line"> +	Fail if the source repository is a shallow repository.
</span><span class="token prefix inserted">></span><span class="token line"> +	The 'clone.rejectShallow' configuration variable can be used to
</span><span class="token prefix inserted">></span><span class="token line"> +	give the default.
</span></span>
使用 `to specify the default` 说起来更顺口一些
I am not a native speaker, either, but I believe that it would "roll off
the tongue" a bit better to say "to specify the default".<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>变量命名问题：</p>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> diff --git a/builtin/clone.c b/builtin/clone.c
</span><span class="token prefix inserted">></span><span class="token line"> index 51e844a2de0a..eeddd68a51f4 100644
</span><span class="token prefix inserted">></span><span class="token line"> --- a/builtin/clone.c
</span><span class="token prefix inserted">></span><span class="token line"> +++ b/builtin/clone.c
</span><span class="token prefix inserted">></span><span class="token line"> @@ -50,6 +50,8 @@ static int option_no_checkout, option_bare, option_mir=
</span></span>ror, option_single_branch
<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line">  static int option_local =3D -1, option_no_hardlinks, option_shared;
</span><span class="token prefix inserted">></span><span class="token line">  static int option_no_tags;
</span><span class="token prefix inserted">></span><span class="token line">  static int option_shallow_submodules;
</span><span class="token prefix inserted">></span><span class="token line"> +static int option_shallow = -1;    /* unspecified */
</span><span class="token prefix inserted">></span><span class="token line"> +static int config_shallow = -1;    /* unspecified */
</span></span>
I would much prefer those variable names to include an indicator that this
is about _rejecting_ shallow clones. I.e. `option_reject_shallow`.

Also, I think that we can do with just a single `option_reject_shallow`
(we do not even need that `reject_shallow` variable in `cmd_clone()`):

<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> in `git_clone_config()`, only override it if it is still unspecified:
</span></span>
	if (!strcmp(k, "clone.rejectshallow") &amp;&amp; option_reject_shallow &lt; 0)
		option_reject_shallow =3D git_config_bool(k,v);

<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> in `cmd_clone()`, test for a _positive_ value:
</span></span>
	if (option_reject_shallow > 0)
		die(_("source repository is shallow, reject to clone."));

<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> and
</span></span>
	if (option_reject_shallow > 0)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">		transport_set_option(transport, TRANS_OPT_REJECT_SHALLOW, "1");
</span></span>
One thing to note (in the commit message, would be my preference) is that
`cmd_clone()` is _particular_ in that it runs `git_config()` _twice_. Once
before the command-line options are parsed, and once after the new Git
repository has been initialized. Note that my suggestion still works with
that: if either the original config, or the new config set
`clone.rejectShallow`, it is picked up correctly, with the latter
overriding the former if both configs want to set it.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>option_reject_shallow</code> 比 <code>config_shallow</code> 更好一些，它能更直接地表明这个选项是要拒绝 <em>shallow clone</em> 的。<s>同时他提醒，在 <code>cmd_clone()</code>函数中 <code>git_config</code> 会被调用两次，使用 <code>option_reject_shallow</code> 能避免在 <code>cmd_clone</code> 中使用 <code>reject_shallow</code></s> 。</p>
<p>P.S. 划线这段话是错误的，见 Johannes 本人回复：<a href="https://public-inbox.org/git/nycvar.QRO.7.76.6.2104010021510.54@tvgsbejvaqbjf.bet/">Johannes’reply</a>，以及 Junio 的回复：<a href="https://public-inbox.org/git/xmqqim5754rl.fsf@gitster.g/">Junio’s reply</a>。最后用了两个变量: <code>option_reject_shallow</code>，<code>config_reject_shallow</code>，在 <code>cmd_clone()</code> 中它们共同决定另一个变量：<code>reject_shallow</code>。</p>
<p>后面同样变量命名：</p>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> diff --git a/fetch-pack.c b/fetch-pack.c
</span><span class="token prefix inserted">></span><span class="token line"> index fb04a76ca263..34d0c2896e2e 100644
</span><span class="token prefix inserted">></span><span class="token line"> --- a/fetch-pack.c
</span><span class="token prefix inserted">></span><span class="token line"> +++ b/fetch-pack.c
</span><span class="token prefix inserted">></span><span class="token line"> @@ -1129,9 +1129,11 @@ static struct ref *do_fetch_pack(struct fetch_pac=
</span></span>k_args *args,
<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line">  	if (args->deepen)
</span><span class="token prefix inserted">></span><span class="token line">  		setup_alternate_shallow(&amp;shallow_lock, &amp;alternate_shallow_file,
</span><span class="token prefix inserted">></span><span class="token line">  					NULL);
</span><span class="token prefix inserted">></span><span class="token line"> -	else if (si->nr_ours || si->nr_theirs)
</span><span class="token prefix inserted">></span><span class="token line"> +	else if (si->nr_ours || si->nr_theirs) &#123;
</span><span class="token prefix inserted">></span><span class="token line"> +		if (args->remote_shallow)
</span></span>
Even as a non-casual reader, this name `remote_shallow` leads me to assume
incorrect things. This option is not about wanting a remote shallow
repository, it is about rejecting a remote shallow repository.
用 `reject_shallow` 代替 `remote_shllow`
Please name this attribute `reject_shallow` instead of `remote_shallow`.
That will prevent future puzzlement.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Johannes 还对测试用例提出了一些检视意见，篇幅有限，这里省略。</p>
<p>在最后几个回合，Junio 又给出了很多有意义的检视意见：</p>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> In some scenarios, users may want more history than the repository
</span><span class="token prefix inserted">></span><span class="token line"> offered for cloning, which happens to be a shallow repository, can
</span><span class="token prefix inserted">></span><span class="token line"> give them. But because users don't know it is a shallow repository
</span><span class="token prefix inserted">></span><span class="token line"> until they download it to local, users should have the option to
</span></span>
'should' 在这里感觉语气太重了
I find the "should" too strong, but let's keep reading.

<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> refuse to clone this kind of repository, and may want to exit the
</span><span class="token prefix inserted">></span><span class="token line"> process immediately without creating any unnecessary files.
</span></span>确认是语气重了。同时存在冗余。
Yes, that is too strong and also redundant.

<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> Althought there is an option '--depth=x' for users to decide how
</span><span class="token prefix inserted">></span><span class="token line"> deep history they can fetch, but as the unshallow cloning's depth
</span></span>句子若以 'although' 开头，则后面不应该用 `but`做转折。
"Although"; if you begin with "although", you shouldn't write "but".

<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> is INFINITY, we can't know exactly the minimun 'x' value that can
</span><span class="token prefix inserted">></span><span class="token line"> satisfy the minimum integrity,
</span><span class="token prefix inserted">></span><span class="token line"> so we can't pass 'x' value to --depth,
</span><span class="token prefix inserted">></span><span class="token line"> and expect this can obtain a complete history of a repository.
</span></span>
If the argument were "we might start with depth x, and the source
may be deep enough to give us x right now, but we may want to deepen
more than they can offer, and such a user would want to be able to
say 'I want depth=x now, but make sure they are not shallow'", I
would understand it, but I do not see where the "minimum integrity"
comes from---there doesn't appear to be anything related to
integrity here.

<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> In other scenarios, if we have an API that allow us to import external
</span></span>
"allows"

<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> repository, and then perform various operations on the repo.
</span><span class="token prefix inserted">></span><span class="token line"> But if the imported is a shallow one(which is actually possible), it
</span><span class="token prefix inserted">></span><span class="token line"> will affect the subsequent operations. So we can choose to refuse to
</span><span class="token prefix inserted">></span><span class="token line"> clone, and let's just import a normal repository.
</span></span>建议丢掉这一整段，因为它跟前面讲的场景差不多，并没有提供新信息。
I'd suggest dropping this entire paragraph.  That is not any new
scenario at all.  API or not, you essentially just said "you can do
various things on your clone once you have it, but some things you
may want to do you would want a full history".  That is what you
started the whole discussion above and does not add any new
information.


<span class="token inserted-arrow inserted"><span class="token prefix inserted">></span><span class="token line"> @@ -858,6 +861,9 @@ static int git_clone_config(const char *k, const char *v, void *cb)
</span><span class="token prefix inserted">></span><span class="token line">  		free(remote_name);
</span><span class="token prefix inserted">></span><span class="token line">  		remote_name = xstrdup(v);
</span><span class="token prefix inserted">></span><span class="token line">  	&#125;
</span><span class="token prefix inserted">></span><span class="token line"> +	if (!strcmp(k, "clone.rejectshallow") &amp;&amp; option_reject_shallow &lt; 0)
</span><span class="token prefix inserted">></span><span class="token line"> +		option_reject_shallow = git_config_bool(k, v);
</span></span>
Does this "single variable is enough" really work?

Imagine that the first time around we'd read from $HOME/.gitconfig
that says true (flips the variable from "unspecified").  Further
imagine that we are running "git clone -c config.rejectShallow=no"
to countermand the global config.  We call write_config() to write
the extra configuration value out, and then call git_config() to
read from the repository configuration again.

Because of the value taken from $HOME/.gitconfig, however, the
attempt to override is silently ignored, isn't it?

Other than that, the changes to the code from the previous round
looked sensible.

虽然比上一版的更新好了很多，但Junio并没有放弃任何可能的问题，仍对config配置
和option配置有疑问，他的顾虑是正确的，这为下一版的更新提供了正确的思路。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就是我第一次向 Git 社区提交代码的情况：问题多多，反馈多多。各种严谨细致又有启发性的检视意见让我感受到了 Git 社区的技术氛围。这个过程中让我不断思考如何让代码写得更好：更有逻辑，更简洁，更严谨，而不仅仅是实现功能。</p>
<p>这个经验让我想到，在英语中有个两个单词可以很贴切的形容他们对待代码的态度：<code>polish</code>，<code>cooking</code>。<br>
<code>polish</code> 动词意为润色，修改，抛光，打磨。用在代码上， commit 信息上，甚至写文档上，意味着这些过程是不断改进，不断变得更好。<br>
<code>cooking</code> 意为烹饪，比喻写代码就像烹饪，所谓心急吃不了热豆腐，即使做简单的菜都需要耐心，细心。</p>
<p>回到主题，前面的每次修改，直接强推到原来的PR中即可， <a href="https://gitgitgadget.github.io/">GitGitGadget</a> 会自动将每次的更新转换为不同的版本再提交到上游社区。那如何确定提交的版本是最终版本呢？前面提到过 Git 的几个主要分支，当我提交到第十版后，很快就被合入到 <code>seen</code>分支，意味着被初步接受，然后又马上进入 <code>next</code> 分支，意味着各项测试也没问题，然后又马上进入 <code>master</code> 分支。特别地，这个过程会有 <strong>状态更新</strong> 提醒， Git 社区有个 <a href="https://lore.kernel.org/git/xmqqy2dw2pai.fsf@gitster.g/#r">What’s cooking in git.git</a> 栏目，是维护者 Junio 用来管理各种提交的状态更新的，它会表明目前社区正在 cooking 哪些人的哪些代码(patch)，以及各个代码的目前状态。当你的代码在 <strong>What’s cooking in git.git</strong>  中进入 <code>Graduated to 'master'</code> 或者 <code>Will merge to 'master'</code>，那就表明马上会合入主线啦。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Workflow</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>一种 Git 插件工具：git repo-clean</title>
    <url>/posts/92e91caf.html</url>
    <content><![CDATA[<p>本篇文章将从如何定义 Git 大仓库，大仓库如何产生，大仓库的负面影响等方面讨论起，然后介绍几款目前针对大仓库的处理工具，并讨论它们的优缺点，然后谈谈我们今天要介绍的新工具<strong>git repo-clean</strong>的一些设计目标，并重点介绍它的设计原理。</p>
<span id="more"></span>
<p>作为国内最大的代码托管平台，Gitee 每天都有大量不同行业的人在上面围绕 Git 仓库进行各种 Git 操作实践。</p>
<p>但是我们经常收到用户的帮助请求，他们的问题往往是其 Git 仓库变得非常大，这影响了他们对仓库做进一步的操作，甚至会导致开发进度落后。</p>
<h5 id="实际场景：">实际场景：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>场景一：</strong></p>
<p>用户不小心使用 <code>git add .</code> 将当前工作区中的所有文件加入到 Git 仓库，并做了提交，但是后来意识到有些文件并不是想要的，如 <code>build/</code>、<code>ThirdPart/</code>、<code>vendor/</code>等目录下的文件，于是想删除掉之前的提交中的部分文件。一般情况下，可以使用 <code>git reset</code>或者 <code>git revert</code>回退当前的 <code>bad commit</code>到它的前一次 <code>commit</code>。但是，由于已经提交了很多正常的有用的 <code>commit</code>，这个时候再回退就需要小心了，因为所有 <code>bad commit</code> 之后的所有正常提交也会被回退。</p>
</li>
<li class="lvl-2">
<p><strong>场景二：</strong></p>
<p>在一个成熟的项目中经过多年的迭代，项目的功能变得与以前非常不同，不断地代码迭代也使得 Git 仓库变得臃肿，再加上在用 Git 管理项目的前期由于使用的不成熟，向仓库提交了很多不必要的文件，这些文件长期存在，而且如果对一个大文件进行过多次修改，每个版本都会完整保存在仓库中，则体积也会成倍增长。之后推送到服务端仓库，也会占用相当大的服务端仓库资源。同时，在协作开发的情况下，意味着每个人都会克隆一个巨大的仓库到本地，而且由于数据量很大，该过程变得很慢。</p>
</li>
</ul>
<h5 id="问题：">问题：</h5>
<p>基于以上场景，可以归纳出 Git 仓库的几种常见的问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>向仓库中提交了大量不必要的文件。如：项目编译过程文件，第三方库文件，多媒体文件等。这导致 Git 仓库的提交文件被污染。</p>
</li>
<li class="lvl-2">
<p>向仓库中提交的单个文件非常大。假如提交了一个 100M 的文件，一方面平台会限制用户推送单个文件大小超过 100M 的文件；另一方面，如果多次修改过这个文件，仓库中将会存在多个版本，比如经过10次修改，每个版本大约还是 100M，那仓库就会因为这个文件，体积变为 <code>10 * 100M</code>，这样仓库总的大小也会变得巨大，也将超过推送限额。</p>
</li>
</ul>
<p>以上都属于是 Git 大仓库问题，根据经验法则，大仓库的衡量维度包括：</p>
<ol>
<li class="lvl-3">
<p>单个文件是否过大</p>
</li>
<li class="lvl-3">
<p>文件数量是否过多, 如数量超过100k</p>
</li>
<li class="lvl-3">
<p>提交数量是否过多，如数量超过100K</p>
</li>
<li class="lvl-3">
<p>分支数/标签数是否过多，如数量超过10K</p>
</li>
<li class="lvl-3">
<p>子模块是否过多，如超过25个子模块</p>
</li>
</ol>
<blockquote>
<p>关于 Git 大仓库的详细说明，可见这篇文章[<a href="https://gitee.com/cactusinhand/all-about-git/blob/master/doc/large-git-repos-zh.md">1]</a>。</p>
</blockquote>
<p>以上衡量标准并不是固定的，只是根据经验所得，是一种参考值，其衡量值往往随着电脑的性能，系统的类型，以及Git 的版本不同而不同。</p>
<p>但是根据这种衡量标准，我们大致能知道怎么样的仓库才算得上大仓库。</p>
<p>我们收到的大仓库问题反馈一般集中在前两种。通常，当出现仓库数据过大的信号后，用户一开始往往会选择删除仓库当前工作区下的文件，而忽略了 Git 仓库是分为工作区，缓存区，对象存储区的结构。当文件提交后，不仅工作区存在该文件，对象存储区也存在该文件，所以只删除工作区的文件，虽然肉眼看不见文件了，但其实它还是存在仓库中，通过一些git命令很容易将它恢复到当前工作区。这说明仓库体积并没用有效的减少。</p>
<p>一方面，Git 是生来是为源代码文件而设计和优化的，而源代码文件一般都不会很大，对于大仓库，Git 的很多操作的性能产生非常大的影响，如果大仓库中问非常多，那么在有遍历操作的git命令的时候就非常耗时；另一方面，Git 是分布式的，一个仓库通常包含所有的修改版本、提交历史。大仓库的数据存储和传输会有一定压力，比如传输很慢，传输超时，或者存储空间不足导致传输失败等。</p>
<p>我们很多时候很难避免制造Git大仓库，所以这些问题很容易出现。对Git的操作比较熟悉的人，会在项目刚开始的时候，通过<code>.gitignore</code> 文件[<a href="https://git-scm.com/docs/gitignore">2]</a>来管理提交到仓库的文件。</p>
<p>在Gitee上新建仓库时，也会提供<code>.gitignore</code>模板文件:</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/gitee_gitignore.png" alt=""></p>
<p>如果仓库中没有这个文件，需要手动新建。</p>
<p>这个文件的作用是将指定类型，或者指定目录下的文件忽视掉，Git就不会将这些文件加入到仓库中，从而保持仓库干净。</p>
<p>使用<code>.gitignore</code>管理仓库文件只是防止仓库污染、体积膨胀的手段之一。</p>
<p>另外一种手段是使用<code>Git LFS</code> 专门来管理仓库大文件，从而避免仓库体积膨胀。</p>
<p>该功能的原理是，使用专门的大文件存储服务器来管理仓库中特定的大文件，而本地仓库只管理大文件的指针。详情可参考：Git LFS 操作指南[<a href="https://gitee.com/help/articles/4235">3]</a>。</p>
<p>如果是仓库中已经存在大量非必要大文件而导致仓库体积膨胀，那么如何解决呢？其实已经有人做出了一些工具，来试图解决此类问题。</p>
<p>我们先来看下几种常见的工具的对比：</p>
<h5 id="同类工具对比：">同类工具对比：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>git-filter-branch[<a href="https://git-scm.com/docs/git-filter-branch">4]</a></p>
</li>
</ul>
<p>特点：</p>
<p>Git 内部自带的命令，只要有 Git 环境，就能使用这个工具。</p>
<p><strong>使用示例：</strong></p>
<pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">$ git filter-branch --tree-filter &#39;rm -f path&#x2F;to&#x2F;large&#x2F;file&#39; --tag-name-filter cat -- --all
$ git reflog expire --expire&#x3D;now --all
$ git gc --prune&#x3D;now --aggressive
$ git push origin --tags --force
$ git push origin --all --force<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>问题：</strong></p>
<ol>
<li class="lvl-3">
<p>使用起来比较复杂；</p>
</li>
<li class="lvl-3">
<p>如果不确定大文件，需要先使用其它命令手动扫描仓库中存在的大文件；</p>
</li>
<li class="lvl-3">
<p>处理过程特别慢[<a href="https://git-scm.com/docs/git-filter-branch#PERFORMANCE">5]</a>!；</p>
</li>
<li class="lvl-3">
<p>如果存在特殊文件名，特殊文件路径，可能会出错，甚至误删文件；</p>
</li>
<li class="lvl-3">
<p>删除文件、重写历史之后，可能旧的和新的历史记录都存在，导致仓库体积反而变大[<a href="https://git-scm.com/docs/git-filter-branch#SAFETY">6]</a>。</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>git-filter-repo[<a href="https://github.com/newren/git-filter-repo">7]</a></p>
</li>
</ul>
<p><strong>特点：</strong></p>
<p>git filter-branch 的官方替代，官方推荐使用该工具来代替原生 <code>git-filter-branch</code> 命令。</p>
<p>速度快，功能多，使用灵活。</p>
<p><strong>使用示例：</strong></p>
<pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">$ git filter-repo --path bigfile.zip --path big&#x2F;files&#x2F;dir&#x2F; --invert-paths
$ git push origin --tags --force
$ git push origin --all --force<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>问题：</strong></p>
<ol>
<li class="lvl-3">
<p>需要删除的文件可能不在当前工作区，而是在历史提交中，用户无法直接提供文件名、文件 ID 进行删除；</p>
</li>
<li class="lvl-3">
<p>依赖 Python 环境。</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>BFG Repo-Cleaner[<a href="https://github.com/rtyley/bfg-repo-cleaner">8]</a></p>
</li>
</ul>
<p><strong>特点：</strong></p>
<p>速度快，使用比较简单。</p>
<p><strong>使用示例：</strong></p>
<pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">$ java -jar bfg.jar --strip-blobs-bigger-than 100M my-big-repo.git
$ cd my-big-repo.git
$ git reflog expire --expire&#x3D;now --all
$ git gc --prune&#x3D;now --aggressive
$ git push origin --tags --force
$ git push origin --all --force<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>问题：</strong></p>
<ol>
<li class="lvl-3">
<p>不会处理最新的 commit(HEAD commit)；</p>
</li>
<li class="lvl-3">
<p>会在所有被处理的 commit 信息中加入额外的信息。如：<code>Former-commit-id: xxxxx</code>，特别是如果多次运行该命令，则会在这些 commit 中加入多条额外信息，这会污染commit信息；</p>
</li>
<li class="lvl-3">
<p>处理之后会在 HEAD commit 中加入很多额外信息；</p>
</li>
<li class="lvl-3">
<p>对松散对象没有做处理；如果松散对象是要删除的大文件，则不会成功；</p>
</li>
<li class="lvl-3">
<p>需要额外手动进行 GC 操作；</p>
</li>
<li class="lvl-3">
<p>依赖 Java 环境。</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>git-siezer[<a href="https://github.com/github/git-sizer">9]</a></p>
</li>
</ul>
<p><strong>特点：</strong></p>
<p>对 Git 仓库中的数据指标进行详细的统计。</p>
<p><strong>使用实例：</strong></p>
<pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">$ git sizer  --threshold&#x3D;0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>问题：</strong></p>
<ol>
<li class="lvl-3">
<p>只是对仓库的数据信息做概括统计。如：总的 commit 数量，总的文件(blob)数量，最大的单个文件等，不能告诉用户最大的 N 个文件，不能进行文件删除、历史重写。</p>
</li>
</ol>
<h5 id="git-repo-clean-设计目标：">git-repo-clean 设计目标：</h5>
<p>通过对以上工具的特点、问题进行总结，我们试图开发出一款工具，解决以下问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>纯命令行方式对有些用户不太友好，并且使用说明都是英文，阅读英文使用文档比较困难</p>
</li>
<li class="lvl-2">
<p>没有自动对仓库进行备份，由于可能误操作，丢失仓库数据</p>
</li>
<li class="lvl-2">
<p>对仓库历史文件不太了解，无法准确知道需要删除哪些文件</p>
</li>
<li class="lvl-2">
<p>删除过程太慢。</p>
</li>
</ul>
<p>这款工具就是：<code>git-repo-clean</code>[<a href="https://gitee.com/oschina/git-repo-clean">10]</a>。</p>
<p>总的来说，<code>git-repo-clean</code> 具备以下<strong>优势</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用简单。支持交互模式，用户操作起来比单纯的命令行方式更简单。</p>
</li>
<li class="lvl-2">
<p>支持扫描模式。当对历史提交文件不太了解时，可以选择先扫描仓库，只需提供文件类型、大小、数量即可扫描出目标历史文件，再进行删除(交互模式下，也会使用扫描模式)，弥补了 <code>git-filter-branch</code>的缺点。</p>
</li>
<li class="lvl-2">
<p>支持直接指定文件进行删除。</p>
</li>
<li class="lvl-2">
<p>支持删除指定目录下的所有文件(包括目录本身)，及其提交记录。</p>
</li>
<li class="lvl-2">
<p>速度快。从 <code>v1.2.0</code> 开始，<code>git-repo-clean</code>的速度可以达到与 <code>git-filter-repo</code> 同级别速度。</p>
</li>
<li class="lvl-2">
<p>无其它依赖。源码使用 Golang 实现，通过交叉编译，最终可执行程序可在多平台兼容，不需要依赖特定的语言环境。</p>
</li>
<li class="lvl-2">
<p>本地化。有中文文档，软件使用界面支持本地化。</p>
</li>
</ul>
<h5 id="git-repo-clean-技术原理：">git-repo-clean 技术原理：</h5>
<p>一般来说，我们要创建一个 Git 仓库，需要以下操作：</p>
<pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">$ git init mini-repo &amp;&amp; cd mini-repo
$ touch README &amp;&amp; echo &quot;first file in repo&quot; &gt; README
$ git add README &amp;&amp; git commit -m &quot;init commit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Git 内部提供了两个命令: <code>git-fast-export</code>, <code>git-fast-import</code>， 他们分别的作用是将 Git 仓库数据(.git/objects)导出为特定格式的 <code>元数据</code>，然后流式读取这种特定格式的元数据，于是就成一个完整的 Git 仓库。</p>
<p>任何符合格式的完整的元数据，输入给 <code>git-fast-import</code> 都能创建一个 Git 仓库。</p>
<p>我们先来看下一组最小完整的 Git 元数据：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">blob    # blob类型，即文件
mark :1 # 标号1
data 32 # 文件大小
FILE: this is the file content. # 文件内容

reset refs&#x2F;heads&#x2F;master  # 分支
commit refs&#x2F;heads&#x2F;master # commit指向的分支
mark :2 # 标号2
author Li Linchao &lt;lilinchao@oschina.cn&gt; 1633749750 +0800        # commit作者
committer Li Linchao &lt;lilinchao@oschina.cn&gt; 1633749750 +0800     # commit提交者
data 65                                                          # commit信息大小
COMMIT: this is the commit message. The file name will be README # commit信息
M 100644 :1 README                          # commit修改的文件，相当于tree,即文件名
# M表示修改modify(新增也是修改)，100644表示文件类型，1表示指向标号为1的blob，README表示blob标号为1的文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过这组元数据，使用 <code>git fast-import</code> 命令，就能创建出一个完整的仓库，里面包含:</p>
<ol>
<li class="lvl-3">
<p>一个文件，文件大小是 32 Bytes, 内容是：<code>FILE: this is the file content.</code></p>
</li>
<li class="lvl-3">
<p>一个分支，分支名为 <code>master</code></p>
</li>
<li class="lvl-3">
<p>一个 commit 提交，表示对 README 文件的修改。提交信息是：<code>COMMIT: this is the commit message. The file name will be README</code></p>
</li>
</ol>
<p>口说无凭，我们来看下这组元数据实际怎么生成一个完整 Git 仓库的。</p>
<p>首先需要在一个空的 Git 仓库中进行操作，然后将上述元数据输入到 <code>git fast-import</code> 中。</p>
<p>假设上述元数据存放在文件 <code>meatadata</code> 中。</p>
<p>接下来，具体操作如下：</p>
<pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">$ git init fake-repo &amp;&amp; cd fake-repo
$ git fast-import --force --quiet --date-format&#x3D;raw-permissive &lt; ..&#x2F;metadata
$ git reset --hard HEAD # 清除缓存区，和工作区，回到最新的commit上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/init_git_repo.png" alt=""></p>
<p>成功之后，刚创建的新仓库 <code>fake-repo</code> 下就有了一个 README 文件，一个 commit 提交，一个 master 分支：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_commit.png" alt=""></p>
<p>README 文件信息和 commit 信息都是根据元数据 <code>metadata</code> 中的定义而来，我们可以任意修改。</p>
<p>可以说，Git 元数据是对 Git 仓库中的底层数据(blob, tree, commit, tag)进行结构化表示。</p>
<p>那么，如果我们想对一个现存的 Git 仓库进行有目的修改，可以先获得该仓库的元数据，然后进行相应操作。</p>
<pre class="line-numbers language-none"><code class="language-none">如何获得一个 Git 仓库的元数据呢？<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那就是前面提到的 <code>git fast-export</code> 命令。</p>
<p><code>git fast-export</code> 命令可以接受很多参数，比如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>--show-original-ids</code> 用于在输出中加入每个数据类型的原始 hash ID, 这个对于重写 commit 历史，或者通过 ID 裁剪 blob 有帮助。</p>
</li>
<li class="lvl-2">
<p><code>--reencode=(yes|no|abort)</code> 用于处理 commit 信息中的编码问题， yes 表示将 commit message 重新编码为 <code>UTF-8</code>。</p>
</li>
<li class="lvl-2">
<p><code>--no-data</code> 会在输出中省略 <code>blob</code> 类型数据。</p>
</li>
</ul>
<p>具体应该使用什么参数，可以根据修改的目的来调整。</p>
<p>例如， 使用<code>--show-original-ids</code>, <code>--reencode</code>, <code>--use-done-feature</code>,<code> --all</code> 选项时的输出如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_fast_export.png" alt=""></p>
<p>到目前为止，我们已经知道如何获取仓库元数据，也知道怎么根据元数据生成一个新的仓库，那么如果我们想要对仓库进行修改，只需要在这个过程中进行<strong>元数据过滤</strong>即可。</p>
<p>所以 <code>git-clean-repo</code> 的大致流程如下：</p>
<pre class="line-numbers language-Gherkin" data-language="Gherkin"><code class="language-Gherkin">git-fast-export
     |
     | output stream
     V
     ---&gt; parser(blob, tree, commit...)
             |
             |
             V
             ----&gt; filter(blob size, blob id, blob diectory...)
                         |
                         |  input stream
                         V
                         ----&gt; git-fast-import
                                            |
                                            |
                                            V
                                         new repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要解析的元数据中存在不同的数据类型， 它们的格式为：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>blob</strong></p>
</li>
</ul>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">blob
mark [mark id]
data [file size]
[file content]
# LF换行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，mark id 的格式为 <code>:n</code>, 比如：<code>:2</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>reset</strong></p>
</li>
</ul>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">reset [ref name]
from [parent id] (optional)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>commit</strong></p>
</li>
</ul>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">commit [ref name]
mark [mark id]
author [author info]
committer [committer info]
data [commit message info size]
[commit message info]
merge [merge parent]
from [from parent]
filechanges
# LF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，<code>filechanges</code> 格式如下：</p>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">[type] [file-mode] [file-id] [file-path]
# type:
# M: modify
# A: add
# C: copy
# D: delete

# file mode:
# 100644 or 644: normal, but non executable file
# 100755 or 755: normal, but executable file
# 120000: symlink
# 160000: gitlink
# 040000: *subdirectory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>tag</strong></p>
</li>
</ul>
<pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">tag [tag name]
mark [mark id]
from [parent id]
original-oid [original object id]
tagger [tagger info]
data [tag message info size]
[tag message]
# LF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>git-fast-export</code> 的输出中，mark 标号(<code>mark ID</code>)比较关键，它是每种数据的原始顺序，以及引用时的索引号。</p>
<p>每当从 <code>git-fast-export</code> 输出流中解析到一种完整的数据，需要对数据中我们关心的字段进行检查。</p>
<p>比如，我们要根据文件大小来过滤掉仓库中的大文件，在解析到 <code>blob</code> 数据类型时，当获取到 <code>blob size</code> 信息时，可以与我们的预期大小进行对比，如果超过预期大小，则可以把这个 <code>blob</code> 标记为可删除状态，整条 <code>blob</code> 数据都不会输入到 <code>git-fast-import</code> 中，这样就做到了文件删除， 同时记住这个 <code>blob</code> 的 <code>mark ID</code>, 后续继续流式输出时，只要涉及到引用该 <code>mark ID</code> 的 <code>commit</code>，需要将其中的 <code>filechanges</code> 进行修改。如果一个 <code>commit</code> 的 <code>filechanges</code> 删减到为零，则整条 <code>commit</code> 需要丢掉，这样就实现了与删除文件相关的 <code>commit</code>的更新。</p>
<p>我们用一组示意图进行说明：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_repo_clean_graph_1.png" alt=""></p>
<p>上图表示一个简单仓库中元数据的组织方式，为了方便展示，省略了tag、引用等数据结构，只突出文件及其提交。</p>
<p>图中有4个文件：<code>Blob-A</code>, <code>Blob-B</code>, <code>Blob-C</code>, <code>Blob-D</code>。</p>
<p>产生了3个提交：<code>Commit-A</code>, <code>Commit-B</code>,<code> Commit-C</code>。</p>
<p><code>Commit-A</code>提交涉及文件<code>Blob-A</code>, <code>Blob-B</code>, <code>Commit-B</code>提交涉及文件<code>Blob-C</code>, <code>Commit-C</code>提交涉及文件<code>Blob-D</code>。</p>
<p>使用<code>git-fast-export</code>导出仓库的元数据时，是按数据的先后顺序流式输出的，这个顺序即是<code>mark ID</code>的顺序。所以，本示例图中的数据顺序就是：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_repo_clean_graph_2.png" alt=""></p>
<p>现在的目标是要删除文件<code>Blob-C</code>，以及它涉及到的提交。</p>
<p>删除的方式可以从文件的几个维度入手：</p>
<ol>
<li class="lvl-3">
<p>文件的名称</p>
</li>
<li class="lvl-3">
<p>文件的ID, 即图中的 <code>original-oid</code></p>
</li>
<li class="lvl-3">
<p>文件的大小，即图中的 <code>data size</code></p>
</li>
</ol>
<p>无论哪种方式，目的是要先筛选出目标文件，然后进行标记。</p>
<p>所谓标记，可以简单的认为是将它的<code>mark ID</code>从原有的序号系统中剔除，即标记为0。</p>
<p>当<code>blob</code>的<code>mark ID</code>标记为0之后，后续解析到的<code>commit</code>时，会检查其中的<code>filechanges</code>，标记为0的<code>filechange</code>会被移除，如果最终的<code>filechanges</code>数量为0，说明该条<code>commit</code>所涉及到的所以修改文件都已经被删除，则整条<code>commit</code>也应该被删除。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_repo_clean_graph_3.png" alt=""></p>
<p>在<code>Blob-C</code>, <code>Commit-B</code>标记为删除之后，后续所有数据的<code>mark ID</code>需要相应的改变, 以便保持一致。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_repo_clean_graph_4.png" alt=""></p>
<p>如<code>Commit-C</code> 的<code>mark ID</code>变为5， <code>parent commit(from)</code>指向3，<code>filechanges</code>指向4。</p>
<p>这样就完成了删除文件<code>Blob-C</code>，以及其涉及到的<code>Commit-C</code>。</p>
<p>对于多文件，或者多分支删除，因为整个过程的数据是流式输出，所有的数据都按<code>出场顺序</code>有自己的唯一编号，所以处理起来是一样的。</p>
<p>以上就是 <code>git-repo-clean</code>的内部原理。</p>
<h5 id="使用建议：">使用建议：</h5>
<p>不管是哪种重写历史的工具，都是对仓库进行破坏性操作，有些事项需要特别注意。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>事项 1：备份你的原始仓库</p>
</li>
</ul>
<blockquote>
<p><code>git repo-clean</code> 在交互模式下，会询问用户是否进行备份，如果选择是，则会自动帮用户进行仓库备份。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>事项 2：重写历史会改变 commit 的 ID 值，可能会影响现存 PR，所以建议先关掉或者合并现存 PR。</p>
</li>
<li class="lvl-2">
<p>事项 3：在本地仓库重写历史并强制推送到远程仓库之后，应该告知所有使用该仓库进行协同开发的人，需要同步远程仓库，避免再将本地旧的历史提交到远程。</p>
</li>
</ul>
<blockquote>
<p>参考远程仓库更改后如何更新本地仓库[<a href="https://gitee.com/oschina/git-repo-clean/blob/main/docs/repo-update.md">11]</a>[<a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/newren/git-filter-repo/docs/html/git-rebase.html">12]</a></p>
</blockquote>
<h5 id="后续：">后续：</h5>
<p>在<code>v1.3.0</code>中我们已经实现将大文件转换为 <code>Git LFS</code> 文件的功能。</p>
<h5 id="引用参考">引用参考</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>[1]. <a href="https://gitee.com/cactusinhand/all-about-git/blob/master/doc/large-git-repos-zh.md">https://gitee.com/cactusinhand/all-about-git/blob/master/doc/large-git-repos-zh.md</a></p>
</li>
<li class="lvl-2">
<p>[2]. <a href="https://git-scm.com/docs/gitignore">https://git-scm.com/docs/gitignore</a></p>
</li>
<li class="lvl-2">
<p>[3]. <a href="https://gitee.com/help/articles/4235">https://gitee.com/help/articles/4235</a></p>
</li>
<li class="lvl-2">
<p>[4]. <a href="https://git-scm.com/docs/git-filter-branch">https://git-scm.com/docs/git-filter-branch</a></p>
</li>
<li class="lvl-2">
<p>[5]. <a href="https://git-scm.com/docs/git-filter-branch#PERFORMANCE">https://git-scm.com/docs/git-filter-branch#PERFORMANCE</a></p>
</li>
<li class="lvl-2">
<p>[6]. <a href="https://git-scm.com/docs/git-filter-branch#SAFETY">https://git-scm.com/docs/git-filter-branch#SAFETY</a></p>
</li>
<li class="lvl-2">
<p>[7]. <a href="https://github.com/newren/git-filter-repo">https://github.com/newren/git-filter-repo</a></p>
</li>
<li class="lvl-2">
<p>[8]. <a href="https://github.com/rtyley/bfg-repo-cleaner">https://github.com/rtyley/bfg-repo-cleaner</a></p>
</li>
<li class="lvl-2">
<p>[9]. <a href="https://github.com/github/git-sizer">https://github.com/github/git-sizer</a></p>
</li>
<li class="lvl-2">
<p>[10]. <a href="https://gitee.com/oschina/git-repo-clean">开源中国/git-repo-clean</a></p>
</li>
<li class="lvl-2">
<p>[11]. <a href="https://gitee.com/oschina/git-repo-clean/blob/main/docs/repo-update.md">https://gitee.com/oschina/git-repo-clean/blob/main/docs/repo-update.md</a></p>
</li>
<li class="lvl-2">
<p>[12]. <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/newren/git-filter-repo/docs/html/git-rebase.html">https://htmlpreview.github.io/?https://raw.githubusercontent.com/newren/git-filter-repo/docs/html/git-rebase.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>如何向 Git 社区提交代码</title>
    <url>/posts/d699447b.html</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>作为目前最流行的开源分布式<strong>版本控制系统</strong>，Git 的诞生超过17年，但目前仍然具有非常活跃的开发者社区，远超出一般开源软件的生命周期，其代码贡献者也已经超过 1.5K，并且仍源源不断有新增贡献者，这使得 Git 能够持续不断地有各种更新、功能优化等等。</p>
<p>但是要想参与到这个大型的国际化的开源社区中来并成为源码贡献者，对于国内大部分开发者来说并不是那么容易。</p>
<p>在 Gitee 架构团队中，我有机会深入探究 <a href="https://cactusinhand.github.io/2022/02/10/git-from-inside-to-outside/">Git的底层原理</a>，以及<a href="https://cactusinhand.github.io/2022/02/12/Git-tool-git-repo-clean/"> Git 的一些应用</a>，这个过程中我也成为了 Git 社区的贡献者。截至目前，我向 Git 社区提交了 <a href="https://git.kernel.org/pub/scm/git/git.git/log/?qt=author&amp;q=lilinchao">4 次代码</a>。现在，作为贡献者中的一员，我很乐意分享这个过程，以便帮助更多人有机会参与到像 Git 这样的大型开源社区中来。</p>
<p>这个系列将从 Git 社区贡献者的角度，向广大开发者分享我如何向 Git 官方社区提交代码，以及从提交代码到最终合并代码的整个过程。</p>
<h2 id="背景">背景</h2>
<p>如果你在使用 Git 时发现了 bug，或者觉得某些命令没有你想要的功能，或者你发现它的帮助文档描述不够清晰让你感到迷惑，你完全可以自己修改 Git 源码，从而实现自己的预期功能。</p>
<h2 id="获取源码">获取源码</h2>
<p>首先从 <a href="https://github.com/git/git">Git 在 Github 镜像仓</a> 上 fork 出一个自己的仓库，然后克隆到本地：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/myfork/git mygit
$ <span class="token builtin class-name">cd</span> mygit
<span class="token comment"># 添加上游远程仓库，便于更新最新代码</span>
$ <span class="token function">git</span> remote <span class="token function">add</span> upstream https://github.com/git/git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="编译源码">编译源码</h2>
<p>确保在未作任何修改之前，代码不缺少任何编译依赖，能够正常编译。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 切出一个自己的主题分支</span>
$ <span class="token function">git</span> checkout -b myown-topic origin/master
$ <span class="token function">make</span> <span class="token assign-left variable">DEVELOPER</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>topic</code> 是个人主题分支，所谓主题就是自己要修改什么那就是什么主题。</p>
</blockquote>
<h2 id="编写代码">编写代码</h2>
<p>其实编写代码的过程就是一个模仿的过程，先观察别人是怎么写的，再模仿写即可。比如，观察别人是如何定义变量，在哪里定义，如何处理缩进，如何定义函数等等，按照同样的风格进行模仿大致是不会出错的。如果想看详细的编码规范，可参考 <a href="https://gitee.com/mirrors/git/blob/master/Documentation/CodingGuidelines">Git 代码编写规范</a></p>
<h2 id="测试代码">测试代码</h2>
<p>测试代码都在 <code>t/</code> 目录下，请阅读 <code>t/README</code> 文档，然后编写测试用例。</p>
<p>运行单项测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> <span class="token assign-left variable">DEVELOPER</span><span class="token operator">=</span><span class="token number">1</span>
$ <span class="token builtin class-name">cd</span> t/ <span class="token operator">&amp;&amp;</span> prove t9999-psuh-tutorial.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>或者运行全部测试，以确保自己的修改没有影响别的代码运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> t/
$ prove -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span> --shuffle t<span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>*.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="文档更新">文档更新</h2>
<p>如果修改是新增某个特性，或者增加某个选项配置等，都需要补充文档，使用说明，manpage等。</p>
<p>Linux环境中需要安装 <code>asciidoc</code> 工具，来支持文档</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> asciidoc
$ <span class="token function">make</span> all doc
$ <span class="token function">make</span> check-docs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对待文档需要跟对待代码一样，因为它们同样重要。和编写代码一样，需要遵循已有文档的风格，详细风格指导文档请参考可参考 <a href="https://gitee.com/mirrors/git/blob/master/Documentation/CodingGuidelines">Git 代码编写规范</a>中的 <code>Writing Documentation</code> 章节。</p>
<h2 id="编写-commit">编写 commit</h2>
<p>编写 commit 信息也是很重要的一步，这个后续系列文章我会专门说明这一点。</p>
<p>创建 commit 的原则，首先是对逻辑上不同的更改进行不同的提交(make separate commits for logically separate changes)，也就是保持每个commit尽量独立且是最小更改。</p>
<p>每条 commit 需要带上签名，使用 <code>git commit -s</code> ，<code>-s/--signoff</code> 选项会在 commit 尾部加上 <code>Signed-off-by：</code>签名信息。</p>
<p>编写commit message 需要遵循一定规范，如下图：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/image-20210209140518653.png" alt=""></p>
<blockquote>
<p>对于commit message, 官方主要维护者说：A canonical form of our log message starts by explaining the need, and then presents the solution at the end.(一个标准的格式的 commit message 应该在开头描述需求，在结尾展示解决方案。)</p>
<p>commit head 部分不超过 50 个字符<br>
commit body 部分不超过 76 个字符</p>
</blockquote>
<h2 id="向社区提交代码">向社区提交代码</h2>
<p>首先有以下几点需要注意：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">Git 仓库主要有 5 个分支，</label><code>master</code>, <code>maint</code>, <code>seen</code>, <code>next</code>, <code>todo</code>。其中：</p>
</li>
</ul>
<blockquote>
<p><code>seen</code> 是观察分支，向官方提交一般补丁，初步被接受后还需先进入观察期，即合并到seen 分支，此时还要继续接受别人的代码检视，可能会继续修改。</p>
<p><code>next</code> 是预备分支，当 <code>seen</code> 上准备好了后，进入 <code>next</code> 分支，接受更多更广泛的测试，保证新补丁不会引发其它 issue。</p>
<p><code>master</code> 是稳定分支， 在 <code>next</code> 分支上的补丁通过各种测试后，就可以进入稳定分支。</p>
<p><code>maint</code> 是维护分支，bugfix 一般在这个分支上进行(也可以在 master 分支上进行)</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">向社区发送邮件至少需要以下邮件地址：</label></p>
</li>
</ul>
<blockquote>
<ol>
<li class="lvl-3">
<p>主送官方邮件列表(必须)： <a href="mailto:git@vger.kernel.org">git@vger.kernel.org</a>。</p>
</li>
<li class="lvl-3">
<p>抄送代码相关人。比如你的补丁修改了某个文件的某行代码，通过 git-blame 知道这行代码之前的修改者，那么最好也要抄送给这个人，因为他应该比你更熟悉这行代码。</p>
</li>
<li class="lvl-3">
<p>抄送现在主要维护者: <a href="mailto:gitster@pobox.com">gitster@pobox.com</a></p>
</li>
</ol>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2">Git 社区交流都是用</label><strong>纯文本邮件</strong>方式，邮件回复有很多种方式，常见的有 top-posting, bottom-posting, interleaved-style(也叫inline-style)。邮件回复方式详情见 <a href="https://en.wikipedia.org/wiki/Posting_style#Interleaved_style">Posting_style Wiki</a></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">Git 官方社区推荐用 inline-style 回复邮件。</label></p>
</li>
</ul>
<p>向官方提交代码的方式主要有两种:</p>
<p>一. 通过 Git 命令行：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>git format-patch 制作补丁包；</p>
</li>
<li class="lvl-3">
<p>git send-email 发送邮件到官方社区。</p>
</li>
</ol>
</blockquote>
<p>二. 通过 <a href="https://gitgitgadget.github.io/">GitGitGadget</a>：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>使用Github的PR工作流，向 <a href="https://github.com/gitgitgadget/git">GitGitGadget 的 Github 仓库</a> 提交 PR；</p>
</li>
<li class="lvl-3">
<p>找人邀请自己，让别人在 PR 评论区发送 /allow(仅针对第一次提交PR的用户)；</p>
</li>
<li class="lvl-3">
<p>Github CI 通过后，发送 /submit 触发脚本，自动发送格式化的邮件到官方社区。</p>
</li>
</ol>
</blockquote>
<p>通过命令发送邮件向社区提交代码的方式遵循的是比较古老的 <code>mailing list</code>(邮件列表)工作流程，对于现在习惯了直接在网页上提交 <code>PR/MR</code> 的用户来说，邮件列表的方式比较复杂，不建议使用这种方式。但是如果想了解的话，可以参考如下链接：<a href="https://github.com/git-for-windows/git/blob/main/CONTRIBUTING.md#submit-your-patch">Submit Your Patch</a><br>
<code>GitGitGadget</code> 相当于一套自动化程序，实现了 <code>Github PR 工作流</code>，使所有人能够直接在 <code>Github</code> 上通过提交 <code>PR</code> 的方式向 <code>Git</code> 官方提交代码，这极大的简化了原来的 <code>mailing list</code>工作流。所有这里推荐使用这种方式进行提交代码。</p>
<p>如何在 Github 上提交 PR 大部分人应该都会，所有这里就不展开讲了。对于第一次向 Git 仓库提交代码的情况，这里简单说明一下：</p>
<p>当在本地仓库按照前面的方式编写好 commit 后，push 到自己 fork 的仓库后，回到 <a href="https://github.com/gitgitgadget/git"><code>gitgitgadget/git</code></a> 仓库，可以看到：<br>
<img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/20220831183759.png" alt=""></p>
<p>只需要点击绿色按钮，就可以创建 PR 了。</p>
<p><code>GitGitGadget</code> 能够检测到用户是第一次提交 PR ，所以 <strong>gitgitgadget bot</strong> 会自动在 PR 下面发送评论，提示用户该如何操作。这里最重要的一点就是用户(你)需要找一个已经向 Git 成功提交过 PR 的人在你的 PR 评论区发送 <code>/allow</code> 指令，这样你才被正真允许提交 PR。</p>
<p>如果一切顺利，这时候你只需要在 PR 评论区发送 <code>/submit</code> 指令，<code>GitGitGadget</code> 程序会自动将你的 PR 转化为 Git 社区能够接受的格式，并发送到 <a href="https://lore.kernel.org/git/">Git 邮件列表</a> 中。</p>
<h2 id="提交成功！">提交成功！</h2>
<p><code>/submit</code> 指令发送成功后，第一次向 Git 社区提交代码就成功啦！但是，这只是成功的第一步，后续的代码检视，以及你对检视意见的回应才是重点。这将在下一篇文章中介绍。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Workflow</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>认证(Authentication)和授权(Authorization)</title>
    <url>/posts/3be69b54.html</url>
    <content><![CDATA[<h3 id="什么是认证和授权">什么是认证和授权</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>认证(Authentication)，识别身份</p>
</li>
<li class="lvl-2">
<p>授权(Authorization)，授予被识别的身份是否有权限获取指定资源，或授予其操作权限</p>
</li>
</ul>
<p>认证的双方是访问者(User)、身份信息持有者(<strong>IdP</strong>/Identity Provider)。</p>
<p>用户持有的唯一标识符(用户名，UUID 等)，密码信息（密码，指纹等）需要与IdP持有的信息匹配才能认证成功。</p>
<p>资源持有者(Source Owner)，控制资源的获取，修改，删除等。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>身份和资源的分离</p>
</li>
</ul>
<p>资源可能是用户自己产生的，也可能是第三方服务器产生的，或者叫做 Service Provider(SP)，也称 Client。</p>
<p>身份和资源的分离即为 <strong>IdP, SP 分离</strong>。</p>
<p>IdP 与 IdP 之前也可以进行资源传递，并授权。这种方式一般称为<strong>联邦授权</strong>。</p>
<br>
<h3 id="LDAP">LDAP</h3>
<p>LDAP(Light Directory Access Protocol)即轻量级目录访问协议，它是一种为<strong>查询</strong>、<strong>浏览</strong>和<strong>搜索</strong>而优化的专业分布式数据库，它呈树状结构组织数据，和<a href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93&amp;spm=1001.2101.3001.7020">关系数据库</a>不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据，所以大多数是用来查询的。LDAP 只是一种协议，可以有多种实现。</p>
<p>一般结构：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/image-20220213014635093.png" alt=""></p>
<p>DIT(Directory Information Tree）目录信息树<br>
dn(Distinguished Name)：一条记录的详细位置，相当于绝对路径(唯一)<br>
rdn(Relative dn) : 相对dn, 相对于相对路径<br>
dc(Domain Component) ：一条记录所属区域 (哪一颗树)<br>
ou(Organization Unit) ：一条记录所属组织 （哪一个分支）<br>
cn/uid(Common Name/user id)：一条记录的名字/ID (哪一个苹果名字)<br>
sn(Surname): 名字前缀(姓)</p>
<p>基本模型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>信息模型，将信息以树状方式组织，基本数据单元是条目(Entry), 条目又由不同属性组成</p>
</li>
<li class="lvl-2">
<p>命名模型，实现一种条目定位方式</p>
</li>
<li class="lvl-2">
<p>功能模型，实现增删改查等功能</p>
</li>
<li class="lvl-2">
<p>安全模型，实现身份认证，安全通道，访问控制</p>
</li>
</ul>
<br>
<h3 id="OAuth2-0">OAuth2.0</h3>
<p><strong>OAuth 2.0</strong> 是一个授权标准协议，主要用于<strong>资源授权</strong>。</p>
<p>前面提到的身份和资源的分离，OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p>
<p>所以，<strong>OAuth 的核心就是向第三方应用颁发令牌</strong>。</p>
<p>根据 OAuth 2.0 协议规范，主要有四个主体：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>授权服务器</strong>(Authorization Server)，负责颁发 Access Token，Authing 是授权服务器。</p>
</li>
<li class="lvl-2">
<p><strong>资源所有者</strong>(Resource Owner)，即<strong>用户</strong>，授权其他人访问他的资源。</p>
</li>
<li class="lvl-2">
<p><strong>调用方</strong>(Client)，即第三方应用。调用方请求获取 Access Token，经过用户授权后，授权服务器为其颁发 Access Token。调用方可以携带 Access Token 到资源服务器访问用户的资源。</p>
</li>
<li class="lvl-2">
<p><strong>资源服务器</strong>(Resouce Server)，存储用户资源。收到 Access Token 后，验证它的被赋予的权限项目，最后返回资源。</p>
</li>
</ul>
<p>这个过程可能还存在其它主体，如浏览器，也称用户代理(User Agent), 服务提供商(Server Provider)等。</p>
<p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0 定义了四种授权方式。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>授权码模式（authorization code）</p>
</li>
<li class="lvl-2">
<p>简化模式（implicit）</p>
</li>
<li class="lvl-2">
<p>密码模式（resource owner password credentials）</p>
</li>
<li class="lvl-2">
<p>客户端模式（client credentials）</p>
</li>
</ul>
<p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与&quot;服务提供商&quot;的认证服务器进行互动。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/auth2.0_code.png" alt=""></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的&quot;重定向URI&quot;（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的&quot;重定向URI&quot;，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
</blockquote>
<br>
<h3 id="OIDC">OIDC</h3>
<p>OIDC(<strong>OpenID Connect</strong> ) 是 <code>OAuth 2.0</code> 协议的超集，能够认证用户并完成资源授权。OIDC的认证和授权分为<strong>四种模式</strong>：授权码模式（Code）、隐式模式（Implicit）、密码模式（Password）、客户端证书模式（Client Credential）</p>
<p>除了 OIDC 协议之外，还存在着许多标准身份协议，例如 SAML 和 CAS。它们的存在意义都是类似的：为了能让素不相识的 SP 和 IdP 进行快速对接，在用户的许可下让 SP 在 IdP 处完成授权，从而访问 IdP 下资源提供者的资源。</p>
<h3 id="参考链接">参考链接</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://www.bbsmax.com/A/RnJWNaBwzq/">理解OAuth 2.0 - 阮一峰的网络日志</a></p>
</li>
<li class="lvl-2">
<p><a href="https://docs.authing.cn/v2/concepts/oidc/oidc-overview.html">OIDC 与 OAuth2.0 综述</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Auth</category>
      </categories>
      <tags>
        <tag>OAuth2.0</tag>
        <tag>LDAP</tag>
        <tag>OIDC</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 的使用笔记</title>
    <url>/posts/4da024a6.html</url>
    <content><![CDATA[<p>记录一下在项目中使用 Docker 时的一些笔记</p>
<span id="more"></span>
<p>从 Docker image 开始</p>
<h2 id="Docker-image">Docker image</h2>
<h3 id="1-从-Docker-Hub-拉取镜像">1. 从 Docker Hub 拉取镜像</h3>
<p>关于 Docker 镜像，可以从 <a href="https://hub.docker.com/">https://hub.docker.com/</a> 中查找我们需要的镜像。然后再使用 docker 命令 docker pull 拉取目标镜像到本地，当然我们可以使用 docker search [name] 直接查找需要的镜像。虽然 docker search 有 --filter 选项对结果进行过滤，但是直接在网页上进行筛选更方便一些。</p>
<p>另外一种方式是我们自己定制自己需要的镜像，因为直接拉取别人制作好的镜像可能不满足我们自己的实际需要，比如别人的镜像中安装了一些我们不需要的依赖。</p>
<h3 id="2-使用-Dockerfile-制作镜像">2. 使用 Dockerfile 制作镜像</h3>
<p>先看示例：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用官方 Python 运行时作为基础镜像</span>
FROM python:3.8-slim

<span class="token comment"># 在容器中设置工作目录</span>
WORKDIR /app

<span class="token comment"># 将当前目录的内容复制到容器中的 /app</span>
COPY <span class="token builtin class-name">.</span> /app

<span class="token comment"># 指定 pip 源</span>
COPY pip.conf /root/.pip/pip.conf
<span class="token comment"># 安装 requirements.txt 中指定的必需包</span>
RUN pip <span class="token function">install</span> -r requirements.txt

<span class="token comment"># 对外暴露端口</span>
EXPOSE <span class="token number">80</span>

<span class="token comment"># 定义环境变量</span>
ENV NAME World

<span class="token comment"># 在容器启动时运行应用程序</span>
CMD <span class="token punctuation">[</span><span class="token string">"python"</span>, <span class="token string">"app.py"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关键指令的解释：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>FROM：指定基础镜像（在此示例中为 Python 镜像）。</p>
</li>
<li class="lvl-2">
<p>WORKDIR：设置容器中的工作目录。</p>
</li>
<li class="lvl-2">
<p>COPY：将文件从主机机器复制到容器中。</p>
</li>
<li class="lvl-2">
<p>RUN：执行命令以安装依赖或执行设置任务。</p>
</li>
<li class="lvl-2">
<p>EXPOSE：将容器的端口暴露给主机系统。</p>
</li>
<li class="lvl-2">
<p>ENV：定义环境变量。</p>
</li>
<li class="lvl-2">
<p>CMD：指定容器启动时要运行的默认命令。</p>
</li>
</ul>
<p>定义了我们自己的 Dockerfile 文件后，在存在 dockerfile 文件的目录下就可以开始制作镜像了，方式为：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> build --network<span class="token operator">=</span>host -t <span class="token operator">&lt;</span>image-name<span class="token operator">></span>:<span class="token operator">&lt;</span>tag<span class="token operator">></span> -f Dockerfile <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样就从 Dockerfile 中创建了我们自己的 docker 镜像了</p>
<p>打包镜像：<br>
docker save 可以将一个或多个镜像归档打包为单个文件，如：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> save  <span class="token operator">&lt;</span>image-name<span class="token operator">></span>:<span class="token operator">&lt;</span>tag<span class="token operator">></span> -o v1-x86_64.docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="3-发布镜像">3. 发布镜像</h3>
<p>前面提到了 Docker Hub，这是存放 docker 镜像的公共仓库。实现存放，分发 docker 镜像的地方称作 <a href="https://docs.docker.com/registry/">Docker Register</a>。</p>
<p>我们在运行 docker pull、docker search 时，实际上是通过 docker daemon 与 docker registry 通信。而 Docker Hub 实际是 Docker Register 的一种实现。</p>
<p>有了公共仓库的概念，那么就有私有仓，但如何创建私有仓库不是现在的主题。在企业内部可以使用 Harbor 来实现 Docker Register， 它在 Docker Registry 上进行了相应的企业级扩展，因此特别适合来搭建企业内部的 docker 镜像仓，提供公司内部使用。</p>
<p>假设企业内部的的 Harbor 服务的地址为： <a href="https://my.harbor.com">https://my.harbor.com</a></p>
<p>要发布前面制作好的镜像，需要先登录：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> login https://my.harbor.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后将本地镜像打上特定的 tag：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> tag source_image<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span> my.harbor.com/my-projects/repository<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后就可以推送了：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> push my.harbor.com/my-projects/repository<span class="token punctuation">[</span>:tag<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="Docker-container">Docker container</h2>
<p>创建新容器的命令有：docker create， docker run</p>
<p>通过 docker --help 查看他们的用法如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>docker create: Create a new container</p>
</li>
<li class="lvl-2">
<p>docker run: Run a command in a new container</p>
</li>
</ul>
<p>可以看到 docker run 与 docker create 的区别是它除了创建新容器，还可以运行命令。</p>
<p>使用 docker create 创建容器成功后，容器状态为 Created， 正常运行的容器状态为 Up， 所以创建容器后，还需要 docker start 来拉起容器。所以一般我们没有使用 docker create 命令创建容器。</p>
<p><em><strong>Tips:</strong></em></p>
<p><strong>一般使用 docker run 命令来创建容器，并加上-d（–detach）选项让新创建的容器在后台（background）运行，而 docker create 命令则没有这个选项。另外要让容器一直保持运行，还可以加上-t（–tty）选项，否则容器会在后台一直是 Exited 状态，当然如果加上了–rm 选项，则会自动将 Exited 状态的容器删除掉，–rm 选项会与–restart 选项冲突，因为当–restart 打开时意味着当容器进入 Exited 状态后会尝试拉起，而–rm 选项则是尝试删除容器，所以它们不能同时使用。</strong></p>
<p>所以创建容器时会这样做：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> run -t -d --rm --name my-container <span class="token operator">&lt;</span>image-id<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>实际上要使用容器并不是这样简单，容器还需要网络，需要共享主机上的一些资源等等。比如要使用主机上的网络，需要加上–network 选项（伴随着网络，往往还有端口映射问题，但这里先不管）。</p>
<p><em><strong>Tips:</strong></em></p>
<p><strong>要想在容器内部访问主机上的文件，需要–volume 选项将主机上的卷挂载到容器内部，这个能力在有些场景下非常重要。比如，当主机采用了 CST 时区（东八区时间），而容器采用了 UTC 时区（标准时间），它们相差 8 个小时，这在查看容器内服务产生的日志时不太方便，于是我想让容器内的时间与主机上的时间保持一致，这个时候只需要将主机上的/etc/localtime 挂载到容器内即可。</strong></p>
<p><strong>再比如，如果主机上有多个容器，而我想在一个容器内去另一个容器内执行命令，那么只需要将主机上的/var/run/docker.sock 挂载到这个容器内即可。</strong></p>
<p>所以实际创建容器时可能是这样：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> run -t -d --rm --net<span class="token operator">=</span>host -v /etc/localtime:/etc/localtime -v var/run/docker.sock:var/run/docker.sock  --name my-container <span class="token operator">&lt;</span>image-id<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当容器运行起来之后，要在容器内执行命令或脚本，可以不进入容器，直接在主机上执行 docker exec</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token operator">&lt;</span>container-name<span class="token operator">></span> commands
<span class="token comment"># or</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token operator">&lt;</span>container-name<span class="token operator">></span> <span class="token function">bash</span> -c <span class="token string">"commands"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果要进入容器内部，则需要加上–tty（-t） 选项和–interactive（-i）选项</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it <span class="token operator">&lt;</span>contaienr-name<span class="token operator">></span> /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="Docker-compose">Docker compose</h2>
<p>Docker compose 是定义和运行多容器服务的工具，它通过 yaml 文件来编排容器服务，官方文档为：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p>
<p>具体怎么用就不写了，看官方文档即可。但使用时有一点需要注意，就是 docker compose 文件（即.yml 配置文件）的版本兼容性问题，这个也可以从官方文档了解。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 炸弹</title>
    <url>/posts/c5ceb3cc.html</url>
    <content><![CDATA[<h4 id="起源">起源</h4>
<p>Git 炸弹因 XML 炸弹(AKA “billion laughs”)而得名，所以要理解 Git 炸弹，我们不妨先从 XML 炸弹说起。</p>
<p>下面是一段 XML 文件示例：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">lolz</span> <span class="token punctuation">[</span><span class="token internal-subset">
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol"laugh</span> <span class="token attr-name">out</span> <span class="token attr-name">loud"</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol2"&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol3"&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol4"&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol5"&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol6"&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol7"&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol8"&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol9"&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"</span><span class="token punctuation">></span></span>
</span><span class="token punctuation">]</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lolz</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&lol9;">&amp;lol9;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lolz</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从 ENTITY 字段看起，每行 ENTITY 代表一个 XML 实体(entity)元素，一共10个实体元素，除了第一个实体 <code>lol</code> 定义了字符串&quot;laugh out loud&quot;(AKA lol)外, 其余实体都是实体引用，它们每个都引用自上一个实体，且重复10次。</p>
<p>此 XML 文件的文档内容部分仅包含对实体<code>lol9</code>的一个实例的引用。但是，当它被 DOM 或 SAX 解析器解析时，遇到<code>lol9</code>时，它会扩展为 10 个<code>lol8</code>，而每个<code>lol8</code>会扩展为10 个<code>lol7</code>，依此类推。到将所有内容扩展为文本lol时，字符串&quot;laugh out loud&quot;的数量已达100,000,000。如果再增加一个类似结构的实体，或者第一个实体<code>lol</code>被定义为10个&quot;laugh out loud&quot;字符串的话，那么将有<code>10亿</code>个&quot;laugh out loud&quot;，即十亿大笑。</p>
<p>这段文本看似内容不多，占用内存不大，但是在解析过程中内容被指数级展开，会消耗大量内存资源，所以有人利用这个原理进行DOS攻击，使被攻击的机器的内存迅速耗尽，从而停止服务。</p>
<p>以上这种 XML 攻击，被称作 XML 炸弹。</p>
<p>Git 炸弹的原理大致也跟XML炸弹类似，它利用了 Git 的某种特性，使得重复的文本内容深度嵌套。所以接下来再来看一下 Git 炸弹的原理。</p>
<h4 id="Git-炸弹原理">Git 炸弹原理</h4>
<p>我们都知道 Git 的基本数据结构有<code>commit</code>,<code>tag</code>, <code>tree</code>, <code>blob</code>, blob 只存储文件内容，tree 存储文件名称，文件目录结构， commit 与 tag 类似于一种引用(reference),指向 tree。</p>
<p>每中数据都有自己的<code>hash ID</code>, 所以对于<code>blob</code>来说，只要其中的内容是一样的，那么其 ID 就是一样的，不管其内容的文件名，文件路径是否相同。换句话说，Git消除了<code>blob</code>的重复，允许不同的文件(文件名，文件路径不同)使用相同的<code>blob</code>，目的是减少文件内容的重复。对于<code>tree</code>也是类似。</p>
<p>所以有人就利用这个特性制作了一个 Git 仓库, 其结构类似：</p>
<p><img src="https:%5Cfastly.jsdelivr.net%5Cgh%5CCactusinhand%5Cimages_repo%5Cimages%5Cgit_bomb.png" alt="git bomb"></p>
<p>之后，只要运行包含树的遍历操作的 Git 命令，如<code>git status</code>, <code>git checkout</code> 等命令，Git 会先在内存中构造出该仓库的树结构，在这种特殊的仓库中，这个过程会消耗大量内存，因此只要这个仓库的树嵌套足够深，内存就会马上被消耗完，相关进程会被终止。</p>
<p>与XML炸弹类似，只要这种嵌套结构达到10层，或者底层的 blob 有10个，则整个过程展开会有 10 亿条 <code>tree</code>(路径)。</p>
<h4 id="制作">制作</h4>
<p>Git炸弹第一次公开讨论是在 2017 年，Kate 在自己的博客[2]中讨论了制作 Git 炸弹的原理以及制作方法，制作程序是用 Python 写的，见：</p>
<blockquote>
<p><a href="https://kate.io/blog/making-your-own-exploding-git-repos">https://kate.io/blog/making-your-own-exploding-git-repos</a></p>
</blockquote>
<h4 id="如何防止">如何防止</h4>
<p>经过 Github 以及漏洞平台 Hackerone 同意后，Kate 公开了自己在 Github 上自己的 git-bomb仓库[3]，并且在自己的博客中公开讨论了 Git 炸弹的相关信息，之后马上引起了 Git 上游社区的关注，并且马上讨论了可能的修复方案: [4]</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Git上游社区，最终补丁: [5]</p>
</li>
</ul>
<p>Git 官方的修复是将遍历树的过程变得更快，使得对 Git 炸弹仓库做任何操作不至于等待很久。其<code>commit message</code>写到：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">You can see this in a pathological case where a commit adds
a very large number of entries, and we limit based on a
broad pathspec. E.g.:

  perl -e '
    chomp(my $blob = `git hash-object -w --stdin &lt;/dev/null`);
    for my $a (1..1000) &#123;
      for my $b (1..1000) &#123;
        print "100644 $blob\t$a/$b\n";
      &#125;
    &#125;
  ' | git update-index --index-info
  git commit -qm add

  git rev-list HEAD -- .

This case takes about 100ms now, but after this patch only
needs 6ms. That's not a huge improvement, but it's easy to
get and it protects us against even more pathological cases
(e.g., going from 1 million to 10 million files would take
ten times as long with the current code, but not increase at
all after this patch).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>这个修复并没有解决处理这种仓库导致内存消耗过大问题，只对处理过程的消耗时间做了一次优化</strong>。</p>
<h4 id="相关-CVE">相关 CVE</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://ubuntu.com/security/CVE-2017-15298">CVE-2017-15298</a></p>
</li>
</ul>
<h4 id="参考链接">参考链接</h4>
<ol>
<li class="lvl-3">
<p><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2009/november/xml-denial-of-service-attacks-and-defenses">microsoft: xml-denial-of-service-attacks-and-defenses</a></p>
</li>
<li class="lvl-3">
<p><a href="https://kate.io/blog/git-bomb">kate’s blog</a></p>
</li>
<li class="lvl-3">
<p><a href="https://github.com/Katee/git-bomb">kate: original git-bomb repo on Github</a></p>
</li>
<li class="lvl-3">
<p><a href="https://public-inbox.org/git/20171013123521.hop5hrfsyagu7znl@sigill.intra.peff.net/T/#m58c560c18f93476e23110a0656a8d525170d14a2">git upstream discussion</a></p>
</li>
<li class="lvl-3">
<p><a href="https://github.com/Cactusinhand/git/commit/a937b37e766479c8e780b17cce9c4b252fd97e40">git upstream fix</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git-bomb</tag>
        <tag>Xml</tag>
      </tags>
  </entry>
  <entry>
    <title>git bundle 格式及应用</title>
    <url>/posts/32c910d1.html</url>
    <content><![CDATA[<p><code>git-bundle</code> 文件是一种将 <code>git objects</code> 数据(git packfile)与仓库引用 <code>refs</code> 结合在一起的一种数据包格式，通过 <code>objects + refs</code> 就能恢复出一个完整的 <code>git</code> 仓库，因此可以用 <code>git-bundle</code> 文件来备份 <code>git</code> 仓库。</p>
<!--  more -->
<h3 id="格式">格式</h3>
<p><code>git bundle v2</code> 格式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bundle    <span class="token operator">=</span> signature *prerequisite *reference LF pack
signature <span class="token operator">=</span> <span class="token string">"# v2 git bundle"</span> LF

prerequisite <span class="token operator">=</span> <span class="token string">"-"</span> obj-id SP comment LF
comment      <span class="token operator">=</span> *CHAR
reference    <span class="token operator">=</span> obj-id SP refname LF

pack         <span class="token operator">=</span> <span class="token punctuation">..</span>. <span class="token punctuation">;</span> packfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>git bundle v3</code> 格式：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bundle    <span class="token operator">=</span> signature *capability *prerequisite *reference LF pack
signature <span class="token operator">=</span> <span class="token string">"# v3 git bundle"</span> LF

capability   <span class="token operator">=</span> <span class="token string">"@"</span> key <span class="token punctuation">[</span><span class="token string">"="</span> value<span class="token punctuation">]</span> LF
prerequisite <span class="token operator">=</span> <span class="token string">"-"</span> obj-id SP comment LF
comment      <span class="token operator">=</span> *CHAR
reference    <span class="token operator">=</span> obj-id SP refname LF
key          <span class="token operator">=</span> <span class="token number">1</span>*<span class="token punctuation">(</span>ALPHA / DIGIT / <span class="token string">"-"</span><span class="token punctuation">)</span>
value        <span class="token operator">=</span> *<span class="token punctuation">(</span>%01-09 / %0b-FF<span class="token punctuation">)</span>

pack         <span class="token operator">=</span> <span class="token punctuation">..</span>. <span class="token punctuation">;</span> packfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注：以上均采用 <code>ABNF</code> 标记法</p>
</blockquote>
<p>可以看出：</p>
<p><code>git bundle v2</code> 包含四个部分：</p>
<ol>
<li class="lvl-3">
<p>签名。标识 <code>git bundle</code> 版本</p>
</li>
<li class="lvl-3">
<p>必要依赖。不包含在当前 <code>bundle包</code> 中，但是被 <code>bundle包</code> 中的数据引用到的数据。</p>
</li>
<li class="lvl-3">
<p>引用。当前 <code>bundle包</code> 中包含的引用。</p>
</li>
<li class="lvl-3">
<p><code>pack文件</code>。<code>git packfile</code></p>
</li>
</ol>
<p><code>git bundle</code> <code>v3</code> 仅比 <code>v2</code> 多了一个 <code>capability</code> 部分。</p>
<p>前面提到过 <code>prerequisite</code> 的概念，其格式为 <code>prerequisite = &quot;-&quot; obj-id SP comment LF</code>，所以来看下这个实际是什么意思。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先打包master分支上最近三次提交</span>
$ <span class="token function">git</span> bundle create recent.bundle master~3<span class="token punctuation">..</span>master
Enumerating objects: <span class="token number">13</span>, done.
Counting objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">13</span>/13<span class="token punctuation">)</span>, done.
Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">8</span>/8<span class="token punctuation">)</span>, done.
Total <span class="token number">9</span> <span class="token punctuation">(</span>delta <span class="token number">3</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, pack-reused <span class="token number">0</span>

<span class="token comment"># 再用 git bundle verify 验证一下这个bundle包有没有外部依赖</span>
$ <span class="token function">git</span> bundle verify recent.bundle
The bundle contains this ref:
0a831168aa94dffaa92f5d73f3e873ef5fd89603 refs/heads/master
The bundle requires this ref:
d5d9b1c95f0012cb7da18deaff6a806f89e48867
recen.bundle is okay<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的结果很明显：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The bundle requires this ref:
d5d9b1c95f0012cb7da18deaff6a806f89e48867<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>再打开这个bundle包文件看下：</p>
<pre class="line-numbers language-tex" data-language="tex"><code class="language-tex"># v2 git bundle
-d5d9b1c95f0012cb7da18deaff6a806f89e48867 demo.tar.gz
0a831168aa94dffaa92f5d73f3e873ef5fd89603 refs&#x2F;heads&#x2F;master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第二行的内容 <code>-d5d9b1c95f0012cb7da18deaff6a806f89e48867 demo.tar.gz</code> 即是<code>prerequisite</code></p>
<p>并且符合格式 <code>prerequisite = &quot;-&quot; obj-id SP comment LF</code></p>
<p>我们看一个实际的 <code>git pack</code> 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PACK^@^@^@^B^@^@^@^C<span class="token operator">&lt;</span><span class="token number">9</span><span class="token operator"><span class="token file-descriptor important">1</span>></span>^Kx^A^A±^@Nÿtree 212ccb4755ab7c489bee69200388139d7f081e7c
author Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span> <span class="token number">1646124003</span> +0800
committer Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span> <span class="token number">1646124003</span> +0800

<span class="token function">add</span> aa.txt
©<span class="token operator">&amp;</span>5A5x^A^A^E^@úÿaaaa
^E<span class="token punctuation">]</span>^A<span class="token operator">&lt;</span>8f<span class="token operator">></span>¢^Bx^A^A"^@Ýÿ100644 aa.txt^@<span class="token punctuation">]</span><span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>8e<span class="token operator">></span>^<span class="token punctuation">]</span>^F^K^L8<span class="token punctuation">&#125;</span>E,ôt^?<span class="token operator">&lt;</span><span class="token number">8</span><span class="token operator"><span class="token file-descriptor important">9</span>></span>ì¹<span class="token operator">&lt;</span><span class="token number">9</span><span class="token operator"><span class="token file-descriptor important">3</span>></span>XQ£÷^KlK<span class="token operator">&lt;</span>9a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token number">9</span><span class="token operator"><span class="token file-descriptor important">3</span>></span>pÃ^@ò<span class="token operator">&amp;</span>bL37©<span class="token operator">&lt;</span><span class="token number">8</span><span class="token operator"><span class="token file-descriptor important">5</span>></span><span class="token punctuation">(</span>ÐâWa^X
~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而此时的 <code>git bundle v2</code> 文件如下：</p>
<blockquote>
<p>git bundle create master.bundle master</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># v2 git bundle</span>
e0caba68a7281d4ff86693745a1617ffc72c3e7d refs/heads/master

PACK^@^@^@^B^@^@^@^C<span class="token operator">&lt;</span><span class="token number">9</span><span class="token operator"><span class="token file-descriptor important">1</span>></span>^Kx^A^A±^@Nÿtree 212ccb4755ab7c489bee69200388139d7f081e7c
author Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span> <span class="token number">1646124003</span> +0800
committer Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span> <span class="token number">1646124003</span> +0800

<span class="token function">add</span> aa.txt
©<span class="token operator">&amp;</span>5A¢^Bx^A^A"^@Ýÿ100644 aa.txt^@<span class="token punctuation">]</span><span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>8e<span class="token operator">></span>^<span class="token punctuation">]</span>^F^K^L8<span class="token punctuation">&#125;</span>E,ôt^?<span class="token operator">&lt;</span><span class="token number">8</span><span class="token operator"><span class="token file-descriptor important">9</span>></span>ì¹<span class="token operator">&lt;</span><span class="token number">9</span><span class="token operator"><span class="token file-descriptor important">3</span>></span>XQ£÷^Kl5x^A^A^E^@úÿaaaa
^E<span class="token punctuation">]</span>^A<span class="token operator">&lt;</span>8f<span class="token operator">></span>,^B<span class="token operator">&lt;</span>9d<span class="token operator">></span>ï<span class="token operator">&lt;</span><span class="token number">8</span><span class="token operator"><span class="token file-descriptor important">9</span>></span>DIr^<span class="token punctuation">\</span><span class="token operator">&lt;</span><span class="token number">8</span><span class="token operator"><span class="token file-descriptor important">7</span>></span>*<span class="token operator">&lt;</span>9b<span class="token operator">></span>Æû^X¹É<span class="token punctuation">&#125;</span>PÖ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>git bundle v3</code> 文件如下:</p>
<blockquote>
<p>git bundle create --version=3 master-v3.bundle master</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># v3 git bundle</span>
@object-format<span class="token operator">=</span>sha1
e0caba68a7281d4ff86693745a1617ffc72c3e7d refs/heads/master

PACK^@^@^@^B^@^@^@^C<span class="token operator">&lt;</span><span class="token number">9</span><span class="token operator"><span class="token file-descriptor important">1</span>></span>^Kx^A^A±^@Nÿtree 212ccb4755ab7c489bee69200388139d7f081e7c
author Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span> <span class="token number">1646124003</span> +0800
committer Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span> <span class="token number">1646124003</span> +0800

<span class="token function">add</span> aa.txt
©<span class="token operator">&amp;</span>5A¢^Bx^A^A"^@Ýÿ100644 aa.txt^@<span class="token punctuation">]</span><span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>8e<span class="token operator">></span>^<span class="token punctuation">]</span>^F^K^L8<span class="token punctuation">&#125;</span>E,ôt^?<span class="token operator">&lt;</span><span class="token number">8</span><span class="token operator"><span class="token file-descriptor important">9</span>></span>ì¹<span class="token operator">&lt;</span><span class="token number">9</span><span class="token operator"><span class="token file-descriptor important">3</span>></span>XQ£÷^Kl5x^A^A^E^@úÿaaaa
^E<span class="token punctuation">]</span>^A<span class="token operator">&lt;</span>8f<span class="token operator">></span>,^B<span class="token operator">&lt;</span>9d<span class="token operator">></span>ï<span class="token operator">&lt;</span><span class="token number">8</span><span class="token operator"><span class="token file-descriptor important">9</span>></span>DIr^<span class="token punctuation">\</span><span class="token operator">&lt;</span><span class="token number">8</span><span class="token operator"><span class="token file-descriptor important">7</span>></span>*<span class="token operator">&lt;</span>9b<span class="token operator">></span>Æû^X¹É<span class="token punctuation">&#125;</span>PÖ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="操作实践">操作实践</h3>
<p>在机器A中的仓库 <code>R1</code> 中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> bundle create file.bundle master
<span class="token comment"># 做个标记</span>
$ <span class="token function">git</span> tag -f lastR2bundle master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>将 <code>file.bundle</code> 转移到机器B上，克隆仓库 <code>R2</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone -b master /path/to/file.bundle R2
Cloning into <span class="token string">'R2'</span><span class="token punctuation">..</span>.
Receiving objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">38</span>/38<span class="token punctuation">)</span>, <span class="token number">7.97</span> KiB <span class="token operator">|</span> <span class="token number">7.97</span> MiB/s, done.
Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">6</span>/6<span class="token punctuation">)</span>, done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>回到仓库 <code>R1</code>，仓库 <code>R1</code> 有了新的提交。然后继续打包：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> bundle create file.bundle lastR2bundle<span class="token punctuation">..</span>master
<span class="token comment"># 做个标记，下次打包时使用</span>
$ <span class="token function">git</span> tag -f lastR2bundle master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>将 <code>file.bundle</code> 转移到机器 <code>B</code> 上，再到 <code>R2</code> 仓库中进行更新：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch
Receiving objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">41</span>/41<span class="token punctuation">)</span>, <span class="token number">8.28</span> KiB <span class="token operator">|</span> <span class="token number">8.28</span> MiB/s, done.
Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">7</span>/7<span class="token punctuation">)</span>, done.
From /home/git/test-git/example/repo.bundle
   d4f54d9<span class="token punctuation">..</span>6a33e12  master     -<span class="token operator">></span> origin/master
   
 <span class="token comment"># 还是在cloned-repo中</span>
$ <span class="token function">git</span> ls-remote
From /path/to/file.bundle
6a33e12f3d7116863a19bf48471c74c597421f8a        HEAD
45eab37d3cb8b5be02a59d3690cb63d3f692f6b9        refs/remotes/origin/master
45eab37d3cb8b5be02a59d3690cb63d3f692f6b9        refs/remotes/origin/HEAD
6a33e12f3d7116863a19bf48471c74c597421f8a        refs/heads/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上操作，看起来都跟读取 Git 远程仓库的一样。<br>
<strong>但是不支持写仓库操作，即 <code>git push</code> 操作。</strong></p>
<p>以上操作就完成了仓库的全量备份和增量备份。</p>
<p>还可以用其它形式进行打包：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> bundle create mybundle v1.0.0<span class="token punctuation">..</span>master
$ <span class="token function">git</span> bundle create mybundle --since<span class="token operator">=</span><span class="token number">10</span>.days master
$ <span class="token function">git</span> bundle create mybundle -10 master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>只要是 <code>git rev-list</code> 能接受的参数，就可以放在 <code>git bundle create mybundle</code> 后面。比如可以使用 <code>--max-age</code> 选项，实现根据时间戳来进行备份，大致过程如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">```Bash
<span class="token comment"># 当前HEAD的时间戳，作为下次备份的起点时间</span>
$ <span class="token function">git</span> cat-file commit HEAD <span class="token operator">|</span> <span class="token function">sed</span> -n <span class="token string">"s/^committer .*> \([0-9]*\) .*/<span class="token entity" title="\1">\1</span>/p"</span> 
<span class="token number">1660809497</span>

<span class="token comment"># --branches 获取refs/heads/下所有相关commits</span>
<span class="token comment"># --tags 获取refs/tags/下所有相关commits</span>
<span class="token comment"># --remotes 获取refs/remotes/下所有相关commits</span>
<span class="token comment"># --all 获取refs/下所有相关commits</span>
<span class="token comment"># --objects 表示commit所关联的所有对象</span>
$ <span class="token function">git</span> bundle create latest.bundle  --max-age<span class="token operator">=</span><span class="token number">1660807920</span> --all --objects

<span class="token comment"># 获取bundle包中的引用信息，可以通过其它选项筛选出部分引用。</span>
$ <span class="token function">git</span> bundle list-heads latest.bundle <span class="token operator">></span> latest.list

<span class="token comment"># 通过git-ls-remote获取bundle包中的所有引用信息。</span>
$ <span class="token function">git</span> ls-remote latest.bundle <span class="token operator">></span> latest.lsremote<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="应用">应用</h3>
<p>目前 Gitlab 的<a href="https://docs.gitlab.com/ee/user/project/settings/import_export.html">仓库导出、导入功能</a>以及阿里云效 CodeUp 的<a href="https://help.aliyun.com/document_detail/217005.html?spm=a2cl9.codeup_devops2020_goldlog_organization.0.0.3bcb1510bKSmJi">仓库备份</a>功能主要就是利用 Git-bundle 特性对 Git 仓库进行打包。</p>
<h3 id="参考链接">参考链接</h3>
<ol>
<li class="lvl-3">
<p><a href="https://git-scm.com/docs/git-bundle">https://git-scm.com/docs/git-bundle</a></p>
</li>
<li class="lvl-3">
<p><a href="https://git-scm.com/docs/bundle-format">https://git-scm.com/docs/bundle-format</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git-bundle</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 Rust 的一些笔记</title>
    <url>/posts/767b1d3c.html</url>
    <content><![CDATA[<p>Rust是一门偏底层的，安全的，高效的开源编程语言。</p>
<span id="more"></span>
<h3 id="工具链">工具链</h3>
<p><code>rustup</code> 是管理<code>Rust</code>版本和相关工具的命令行工具(rust toolchain installer)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>rustup update</code> 更新<code>Rust</code>版本</p>
</li>
<li class="lvl-2">
<p><code>rustup self uninstall</code> 卸载<code>Rust</code>以及<code>rustup</code>本身</p>
</li>
</ul>
<p><code>Rust</code>工具链中包括<code>rustc</code>编译器工具，<code>rustfmt</code>格式化工具，<code>rustdoc</code>文档化工具等。</p>
<p><code>rustc</code>类似于C/C++中的<code>gcc/clang</code></p>
<p><code>Cargo</code> 是 <code>Rust</code> 的构建系统和包管理器。可以进行构建代码、下载依赖库并编译这些库等。</p>
<p><code>cargo new rust-proj</code> 创建一个Rust项目，</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cargo new rust-proj
     Created binary <span class="token punctuation">(</span>application<span class="token punctuation">)</span> <span class="token variable"><span class="token variable">`</span>rust-proj<span class="token variable">`</span></span> package
$ tree rust-proj
rust-proj
├── Cargo.toml
└── src
    └── main.rs

<span class="token number">1</span> directory, <span class="token number">2</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Cargo</code>会在 <em>hello_cargo</em> 目录初始化一个 git 仓库，以及一个<code>.gitignore</code>文件。如果你在现有的 git 仓库中运行 <code>cargo new</code>，则不会生成 git 文件；你可以通过使用<code>cargo new --vcs=git</code> 来覆盖此行为。</p>
<p>可以通过 <code>--vcs</code> 参数使 <code>cargo new</code> 切换到其它版本控制系统（<code>VCS</code>），或者不使用 <code>VCS</code>。运行 <code>cargo new --help</code> 参看可用的选项。</p>
<p><code>cargo build</code>构建项目，目标可执行文件在<code>target/debug/</code>下</p>
<p><code>cargo run</code>则是构建项目并运行。</p>
<p><code>cargo check</code> 检查项目代码正确，确保可编译。不会产生可执行文件。</p>
<p><code>cargo build</code>默认构建是debug模式。如果项目一切都OK，可以运行<code>cargo build --release</code>执行发布构建，这会对项目进行一定编译优化，从而使得代码运行得更快，但是相应地，编译时间会更长。</p>
<p><code>cargo doc --open</code> 会生成当前项目中的依赖库(crate)的文档，并转到浏览器可以查询。</p>
<h3 id="Hello-World">Hello, World!</h3>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>println!</code> 调用了一个 Rust 宏（macro）。如果是调用函数，则应输入 <code>println</code>（没有<code>!</code>）。我们将在第十九章详细讨论宏。现在你只需记住，当看到符号 <code>!</code> 的时候，就意味着调用的是宏而不是普通函数，并且宏并不总是遵循与函数相同的规则。</p>
</li>
</ul>
<p><code>cargo new</code>生成的项目中，包含配置文件<code>Cargo.toml</code></p>
<p>文件名: <code>Cargo.toml</code></p>
<pre class="line-numbers language-toml" data-language="toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">dependencies</span><span class="token punctuation">]</span>

<span class="token key property">rand</span> <span class="token punctuation">=</span> <span class="token string">"0.8.3"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中“0.8.3”指定依赖版本，其语法遵循语义化版本<a href="http://semver.org/">（Semantic Versioning）</a></p>
<p>这里的<code>0.8.3</code> 实际上是 <code>^0.8.3</code> 的简写，它表示 任何不低于 <code>0.8.3</code>， 但是低于 <code>0.9.0</code> 的版本。Cargo将这些版本视作与 <code>0.8.3</code> 版本公有 API 相兼容的版本，这个声明确保你将获得最新的补丁版本，它仍然可以与本章中的代码正常编译。<code>0.9.0</code> 或以上版本不保证拥有接下来示例中使用到的API。</p>
<hr>
<h3 id="一些定义">一些定义</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Rust变量默认是不可改变的（immutable），如果想声明可变变量，需要使用<code>mut</code>关键字。</p>
</li>
<li class="lvl-2">
<p>Rust不允许对常量使用 <code>mut</code>。常量不光默认不能变，它总是不能变。其声明使用<code>const</code>，且必须标注类型。</p>
</li>
<li class="lvl-2">
<p>整型变量分有符号和无符号，如<code>i8</code>表示有符号8位整数，<code>u8</code>表示无符号8位整数，<code>i128</code>表示有符号128位整数。</p>
</li>
<li class="lvl-2">
<p>还有一种整型依赖计算机架构，<code>isize</code>, <code>usize</code>在不同的架构中表示的长度会不同。</p>
</li>
<li class="lvl-2">
<p>整型字面值有十六进制(<code>0xff</code>)，八进制(<code>0o77</code>)，二进制(<code>0b11</code>)，以及十进制(99_999)，单字节字符(仅限<code>u8</code>)</p>
</li>
<li class="lvl-2">
<p>Rust默认数字类型是<code>i32</code></p>
</li>
<li class="lvl-2">
<p>浮点型变量有两种，<code>f32</code>表示单精度浮点小数，<code>f64</code>表示双精度浮点小数。默认是<code>f64</code>。</p>
</li>
<li class="lvl-2">
<p>字符类型（char）用单引号表示，其大小为4个字节，表示了一个Unicode标量值。</p>
</li>
<li class="lvl-2">
<p>复合类型元组(tuple)一旦声明，其长度不变，其中每一个位置都有一个类型的值，类型可以不同。</p>
</li>
<li class="lvl-2">
<p>复合类型数组(array)长度也是固定的，而且其中类型必须相同。</p>
</li>
</ul>
<p><strong>语句(statement)和表达式(expression)</strong></p>
<p>Rust是一门基于表达式的语言。</p>
<p>语句是执行一些操作，但是不返回值的指令。</p>
<p><code>函数定义</code>就是一个语句。</p>
<p>表达式计算并产生一个值，可以赋予其它变量。</p>
<p><code>函数调用</code>是一个表达式，大括号创建的块作用域也是一个表达式。</p>
<p><code>表达式的结尾没有分号，如果结尾加上分号，则变成了语句。</code></p>
<p>数字本身就是一个表达式，所以它可以返回本身的值赋值给其它变量。</p>
<p>栈(stack)中的数据必须占用已知且大小固定的大小。</p>
<p>当数据大小未知，或大小可能变化的时候，需要用堆(heap)。比如使用内存分配器memory allocator分配指定大小的内存，此时该块内存会被标记为已用，并且以指针来表示这块内存。</p>
<p>而将数据放入栈中的过程并不叫做分配内存，因为这个过程并没有新的内存被分配。</p>
<p>堆的指针可以存储在栈上。</p>
<p>入栈比在堆上分配内存要快。</p>
<p>访问堆中的数据比访问栈上的数据要慢，因为访问堆首先要通过指针来访问，而指针在栈上。</p>
<hr>
<h3 id="一些笔记">一些笔记</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义变量用动词let</p>
</li>
<li class="lvl-2">
<p>借鉴Python的元组</p>
</li>
<li class="lvl-2">
<p>借鉴C++的指针</p>
</li>
<li class="lvl-2">
<p>完善的包管理工具cargo</p>
</li>
<li class="lvl-2">
<p>友好的文档管理</p>
</li>
<li class="lvl-2">
<p>使用先进的VCS管理项目</p>
</li>
<li class="lvl-2">
<p>无垃圾回收机制，使用变量所有权管理内存</p>
</li>
<li class="lvl-2">
<p>编译与执行分开，更早的发现错误</p>
</li>
<li class="lvl-2">
<p>浅拷贝与深拷贝，默认不进行数据的深拷贝，深拷贝使用clone方法</p>
</li>
<li class="lvl-2">
<p>移动(move)操作</p>
</li>
<li class="lvl-2">
<p>Copy trait</p>
</li>
<li class="lvl-2">
<p>栈上数据；堆上数据；既在栈上，又在推上(数据指针在栈上，数据内容在堆上)数据</p>
</li>
<li class="lvl-2">
<p>默认行为：默认变量不可变</p>
</li>
<li class="lvl-2">
<p>引用(ref)变量默认也不能修改其引用的值</p>
</li>
<li class="lvl-2">
<p>一个引用的作用域从声明的地方开始一直持续到最后一次使用为止</p>
</li>
<li class="lvl-2">
<p>字符串slice</p>
</li>
</ul>
<hr>
<ul class="lvl-0">
<li class="lvl-2">
<p>Rust可以直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。</p>
</li>
</ul>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">&#123;</span>
    <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"::1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul class="lvl-0">
<li class="lvl-2">
<p>Rust没有空值(Null)，因为空值会导致很多错误，而是实现了一个枚举变量<code>Option&lt;T&gt;</code>：</p>
</li>
</ul>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">None</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">let</span> some_number <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token string">"a string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
# 当为<span class="token class-name">None</span>时，必须显示指定类型<span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">let</span> absent_number<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">None</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于字符串方法，以下两种方法等效：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"initial contents"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token string">"initial contents"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>参考链接：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://www.rust-lang.org/zh-CN">rust中文官网</a></p>
</li>
<li class="lvl-2">
<p><a href="https://kaisery.github.io/trpl-zh-cn/">rust book</a></p>
</li>
<li class="lvl-2">
<p><a href="https://book.rust.team/into-rust.html">rust course</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 内部原理</title>
    <url>/posts/4fad1e06.html</url>
    <content><![CDATA[<p>本文将深入分析 Git 底层的核心数据结构，如 <code>blob</code>, <code>tree</code>, <code>commit</code>, <code>tag</code> 。通过理解底层数据结构，我们就会更容易理解和掌握相关 Git 命令操作。</p>
<span id="more"></span>
<p>普通Git仓库分为：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>工作区(workspace/working copy)</p>
</li>
<li class="lvl-2">
<p>暂存区(stage/index)</p>
</li>
<li class="lvl-2">
<p>仓库区(local repository/objects database)</p>
</li>
</ul>
<p>裸仓就是不包含工作区的仓库，一般服务端的仓库(即远程库)就是裸仓。</p>
<p>仓库名结尾一般使用 <code>.git</code>为了与正常仓库区分，但不是强制。</p>
<p>创建裸仓的方式有两种：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> init --bare <span class="token operator">&lt;</span>bare-repo<span class="token operator">></span>
$ <span class="token function">git</span> clone --bare source-repo <span class="token operator">&lt;</span>bare-repo<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们新建一个空的裸仓, 命名为 <code>remote.git</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> init --bare remote.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后再创建两个副本，后续的实验就是在repo_a, repo_b中进行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone remote.git repo_a
$ <span class="token function">git</span> clone remote.git repo_b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>进入刚克隆的一个仓库 <code>repo_a</code> 中，只有 <code>.git</code> 目录，<code>.git</code> 目录中的所有文件，即是裸仓中的所有文件，但作为一个正常仓库，目前它工作区还是为空。好在我们可以手动创建一些内容。</p>
<h3 id="认识blob-object"><strong>认识blob object</strong></h3>
<p><strong>git hash-object</strong>： 将数据保存到对象数据库中</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> -n <span class="token string">'Hello, Git'</span> <span class="token operator">></span> README
$ <span class="token function">git</span> hash-object -w README
6fe402b35d6e80a187adc393f36ce10e4fdd259f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>选项-n 为了避免echo在输出字符串时自动添加换行符。</p>
<p>选项 <code>-w</code>表示写入，如果不加这个选项，则仅是计算文件的hash值，不会保存。</p>
</blockquote>
<p>这里将内容 <code>Hello, Git</code> 写入文件README，再对该文件运行了 <code>git hash-objects</code> 命令，并返回了一串值。这串值会以某种形式下保存下来。</p>
<p>用 <code>git count-objects</code> 命令得知，此时仓库已经有了第一个对象：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> count-objects
$ <span class="token number">1</span> objects, <span class="token number">4</span> kilobytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以通过  <code>tree</code> 命令查看下 <code>.git/objects</code> 目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tree .git/objects
.git/objects
├── 6f
│   └── e402b35d6e80a187adc393f36ce10e4fdd259f
├── info
└── pack

<span class="token number">3</span> directories, <span class="token number">1</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们把 <code>.git/objects</code> 目录称作对象数据库(object database)，新增的对象都会存到这个目录下。</p>
<p>里面还是熟悉的那串数字，我们对Git的认识就从这一串数字开始。</p>
<p><strong>git cat-file</strong> ： 剖析git数据对象</p>
<p>通过 <code>git cat-file</code> 命令查看新生成的对象：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -p 6fe402b35d6e80a187adc393f36ce10e4fdd259f
Hello, Git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>顺便还可以看一下对象的类型：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$git</span> cat-file -t 6fe402b35d6e80a187adc393f36ce10e4fdd259f
blob<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里，我们认识到了git对象中的第一种类型<strong>blob object</strong>, 称之为数据对象。</p>
<p>我们创建了一个文件，内容是 <code>Hello, Git</code>,  通过 <code>git hash-object</code>命令将内容写入到 <code>.git/objects</code>目录中，并且返回指向该数据对象的唯一的键，它是一个40-bit的hash值，通过这串值即可寻找出它对应的文件的内容，因此blob数据对象可表示如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/image-20220213174201053.png" alt="image-20220213174201053"></p>
<p>这也是Git的内容可寻址的文件系统(Content-Addressable Filesystem)的含义。</p>
<p>同时我们也知道了Git会将这40-bit的hash值的前2位作为 <code>.git/objects</code>目录下的子目录，后38位作为子目录下的一个文件的文件名。</p>
<p>通过 <code>file</code>命令我们可以知道这是一个zlib压缩文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">file</span> .git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f
.git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f: zlib compressed data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>既然是被压缩过的，那么里面的内容就是不可读的。</p>
<p>为了查看里面的内容，先安装一个解压缩工具：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt-get</span> update
$ <span class="token function">apt-get</span> <span class="token function">install</span> pigz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pigz -d <span class="token operator">&lt;</span> .git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f
blob 10Hello, Git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>-d 表示解压</p>
</blockquote>
<p>可以看到在进行hash时，git内部是按照特定格式进行的:</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/image-20220213174240793.png" alt="image-20220213174240793"></p>
<p>切到 <code>repo_b</code>，我们可以手动验证这个过程：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> -ne <span class="token string">'blob 10\0Hello, Git'</span> <span class="token operator">|</span> sha1sum
6fe402b35d6e80a187adc393f36ce10e4fdd259f  -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>选项-e 为了让echo能够识别反斜杠转义符（即字符串中的’\0’)</p>
</blockquote>
<p>再次使用 <code>git hash-objects</code> 验证这条数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> -n <span class="token string">'Hello, Git'</span> <span class="token operator">|</span> <span class="token function">git</span> hash-object --stdin
6fe402b35d6e80a187adc393f36ce10e4fdd259f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>结果是一致的，说明 <code>git hash-objects</code> 在生成hash时，是严格按照特定格式进行的。</p>
<p>此时并没有创建 <code>.git/objects/6f</code> 目录，因为没有加 <code>-w</code> 选项，我们可以手动完成。</p>
<p>我们知道Git会对数据使用 zlib 的 deflate 算法进行压缩，我们也手动验证一下：</p>
<p>创建一个目录和文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> .git/objects/6f
$ <span class="token function">touch</span> .git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接着，使用 pigz 工具压缩数据，存放到 <code>e402b35d6e80a187adc393f36ce10e4fdd259f</code> 文件中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> -ne <span class="token string">'blob 10\0Hello, Git'</span> <span class="token operator">|</span> pigz -cz <span class="token operator">></span> .git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>-c 表示输出，-z 表示采用zlib的deflate算法</p>
</blockquote>
<p>此时我们才可以用 <code>git cat-file </code>查看一下里面的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -p 6fe402b35d6e80a187adc393f36ce10e4fdd259f
Hello, Git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>同样我们可以 <code>解压</code>，看看压缩文件里面的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pigz -d <span class="token operator">&lt;</span>  .git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f
blob 10Hello, Git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>结果是与前面一致的。</p>
<hr>
<p>回到 <code>repo_a</code> 仓库继续实验其它内容。</p>
<p>再对README文件进行修改：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 改写文件</span>
$ <span class="token builtin class-name">echo</span> -n <span class="token string">"Hello, Gitee"</span> <span class="token operator">></span> README
<span class="token comment"># 写入对象数据库</span>
$ <span class="token function">git</span> hash-object -w README
216ef921a90b782fed1ca37223c3141ed7d5de32
<span class="token comment"># 查看内容</span>
$ <span class="token function">git</span> cat-file -p 216ef921a90b782fed1ca37223c3141ed7d5de32
Hello, Gitee<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再次查看一下 <code>.git/object</code>目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tree .git/objects
.git/objects
├── <span class="token number">21</span>
│   └── 6ef921a90b782fed1ca37223c3141ed7d5de32
├── 6f
│   └── e402b35d6e80a187adc393f36ce10e4fdd259f
├── info
└── pack

<span class="token number">4</span> directories, <span class="token number">2</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>里面有两个 Git 对象了，它们分别代表 README 的两个版本。</p>
<p>我们写入了 blob 对象，通过 <code>git status</code> 查看工作区状态，可以看到 README 仍是 <code>Untracked files</code> 状态，也就是暂存区还是空的，此时 <code>.git/</code> 目录中还不存在 <code>index</code> 文件。</p>
<p>我们可以先更新一下暂存区，需要用到新的命令：</p>
<p><strong>git update-index</strong>: 将工作区的文件内容更新到 index 区</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> update-index --add --cacheinfo <span class="token number">100644</span> 6fe402b35d6e80a187adc393f36ce10e4fdd259f README<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>–add 表示加到Index中</p>
<p>–cacheinfo表示是从git数据库.git/object中添加文件</p>
<p>100644表示普通文件</p>
</blockquote>
<p>再次 git status 查看状态，就不一样了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> status
On branch master

No commits yet

Changes to be committed:
  <span class="token punctuation">(</span>use <span class="token string">"git rm --cached &lt;file>..."</span> to unstage<span class="token punctuation">)</span>
        new file:   README    <span class="token comment">#version 1 index区</span>

Changes not staged <span class="token keyword">for</span> commit:
  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>
  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>
        modified:   README    <span class="token comment">#version 2 工作区</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时我们也可以看到生成了文件 <code>.git/index</code>。</p>
<p>以上过程相当于 <code>git add REAME</code></p>
<p>所以 <code>git add file</code> 就是将工作区的文件内容更新到暂存区。</p>
<hr>
<h3 id="认识tree-object"><strong>认识tree object</strong></h3>
<p>前面认识的 blob 对象只是文件的内容本身，以及它的hash值，并没有涉及到文件名，要保存文件名需要 tree 对象。</p>
<p><strong>git write-tree</strong>:  从当前 index 区创建树对象</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> write-tree
16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c  <span class="token comment"># tree 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>又生成了一个 hash 值。查看一下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -t 16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c
tree

$ <span class="token function">git</span> cat-file -p 16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c
<span class="token number">100644</span> blob 6fe402b35d6e80a187adc393f36ce10e4fdd259f    README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内容与之前暂存区的内容一致，说明确实是从暂存区到了数据库。</p>
<p>这样我们也就认识到了 git 对象中的第二种类型 <strong>tree object</strong>，即树对象。</p>
<p>tree 对象不仅可以保存文件名，还可以保存多个文件的内容及其唯一键，而且它还允许嵌套子树，这相当于文件目录。</p>
<p>我们先再建一棵树：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">'1.0'</span> <span class="token operator">></span> VERSION
$ <span class="token function">git</span> update-index --add VERSION
$ <span class="token function">git</span> update-index --add README  <span class="token comment"># version 2</span>

$ <span class="token function">git</span> status
On branch master

No commits yet

Changes to be committed:
  <span class="token punctuation">(</span>use <span class="token string">"git rm --cached &lt;file>..."</span> to unstage<span class="token punctuation">)</span>
        new file:   README
        new file:   VERSION   
 
$ <span class="token function">git</span> write-tree
33ad99f76f295411d5c198cb58c5c95e5d0b3c91  <span class="token comment"># tree 2</span>

$ <span class="token function">git</span> cat-file -p 33ad99f76f295411d5c198cb58c5c95e5d0b3c91
<span class="token number">100644</span> blob 216ef921a90b782fed1ca37223c3141ed7d5de32    README
<span class="token number">100644</span> blob d3827e75a5cadb9fe4a27e1cb9b6d192e7323120    VERSION<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个目录树包含两个文件对象。</p>
<p>其实还可以包含子树，我们可以利用 <code>git read-tree</code> 把第一棵树整个读入暂存区，然后再写入Git 的数据库。</p>
<p><strong>git read-tree</strong>: 将树信息读到暂存区</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 第一棵树读到index区，并放到bak下面</span>
$ <span class="token function">git</span> read-tree --prefix<span class="token operator">=</span>bak 16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c
<span class="token comment"># 将当前整个状态写入新的树，放回数据库</span>
$ <span class="token function">git</span> write-tree
77e9ad8de018dab58d76e0667507378b3cfe4808  <span class="token comment"># tree 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是此时并没有创建正真的 bak 目录，至少在工作区是没有的(<code>ls</code>查看不到)，它目前只存在于暂存区中</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> status
On branch master

No commits yet

Changes to be committed:
  <span class="token punctuation">(</span>use <span class="token string">"git rm --cached &lt;file>..."</span> to unstage<span class="token punctuation">)</span>
        new file:   README
        new file:   VERSION
        new file:   bak/README

Changes not staged <span class="token keyword">for</span> commit:
  <span class="token punctuation">(</span>use <span class="token string">"git add/rm &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>
  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>
        deleted:    bak/README<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时只需要使用 <code>git checkout </code>命令将它从暂存区恢复到工作区就行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout -- bak/README
$ <span class="token function">git</span> status
<span class="token comment"># 此时可以观察到确实有这个目录了</span>
$ <span class="token function">ls</span>
README  VERSION  bak<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时别忘了 <code>git cat-file</code> 查看新树：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -p 77e9ad8de018dab58d76e0667507378b3cfe4808
<span class="token number">100644</span> blob 216ef921a90b782fed1ca37223c3141ed7d5de32    README
<span class="token number">100644</span> blob d3827e75a5cadb9fe4a27e1cb9b6d192e7323120    VERSION
040000 tree 16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c    bak<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>100644表示普通文件，040000 表示目录</p>
</blockquote>
<p>用一张图表示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/image-20220213174314167.png" alt="image-20220213174314167"></p>
<h3 id="认识commit-object"><strong>认识commit object</strong></h3>
<p><strong>git commit-tree</strong>： 创建 commit 对象</p>
<p>目前我们有三棵树：<code>16ab2</code>， <code>33ad9</code>， <code>77e9a</code></p>
<p>现在可以根据树来创建 <strong>commit</strong>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">'first commit'</span> <span class="token operator">|</span> <span class="token function">git</span> commit-tree 16ab2
3aa1317953001375c744a8a12f59a37cc1640fdb
$ <span class="token function">git</span> log 3aa13
commit 3aa1317953001375c744a8a12f59a37cc1640fdb
Author: Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span>
Date:   Mon Aug <span class="token number">16</span> <span class="token number">16</span>:16:31 <span class="token number">2021</span> +0800

    first commit
<span class="token punctuation">(</span>END<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -t 3aa1317953001375c744a8a12f59a37cc1640fdb
commit
$ <span class="token function">git</span> cat-file -p 3aa1317953001375c744a8a12f59a37cc1640fdb
tree 16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c
author Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span> <span class="token number">1629101791</span> +0800
committer Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span> <span class="token number">1629101791</span> +0800

first commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个过程相当于 <code>git commit  -m  &quot;message&quot;</code>。</p>
<p>以上就创建了 git 对象中的第三种类型 <strong>commit object</strong>，即提交对象</p>
<p>其它的 commit 时按照 tree 生成的顺序来：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">'second commit'</span> <span class="token operator">|</span> <span class="token function">git</span> commit-tree 33ad9 -p 3aa13
2aa80fc99a89a808fc0342972c5a3514d41fa5f7
$ <span class="token function">git</span> log 2aa8
commit 2aa80fc99a89a808fc0342972c5a3514d41fa5f7
Author: Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span>
Date:   Mon Aug <span class="token number">16</span> <span class="token number">16</span>:21:42 <span class="token number">2021</span> +0800

    second commit

commit 3aa1317953001375c744a8a12f59a37cc1640fdb
Author: Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span>
Date:   Mon Aug <span class="token number">16</span> <span class="token number">16</span>:16:31 <span class="token number">2021</span> +0800

    first commit
<span class="token punctuation">(</span>END<span class="token punctuation">)</span>


$ <span class="token builtin class-name">echo</span> <span class="token string">'third commit'</span> <span class="token operator">|</span> <span class="token function">git</span> commit-tree 77e9a -p 2aa80
bdc5642cd9e8a62767710d1d9761b056f91f094c
$ <span class="token function">git</span> log bdc56
commit bdc5642cd9e8a62767710d1d9761b056f91f094c
Author: Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span>
Date:   Mon Aug <span class="token number">16</span> <span class="token number">16</span>:23:00 <span class="token number">2021</span> +0800

    third commit

commit 2aa80fc99a89a808fc0342972c5a3514d41fa5f7
Author: Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span>
Date:   Mon Aug <span class="token number">16</span> <span class="token number">16</span>:21:42 <span class="token number">2021</span> +0800

    second commit

commit 3aa1317953001375c744a8a12f59a37cc1640fdb
Author: Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span>
Date:   Mon Aug <span class="token number">16</span> <span class="token number">16</span>:16:31 <span class="token number">2021</span> +0800

    first commit
<span class="token punctuation">(</span>END<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不管是数据对象(blob object), 树对象(tree object), 提交对象(commit object)，所有的对象都会放到对象数据库中：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tree .git/objects
.git/objects
├── <span class="token number">16</span>
│   └── ab25f42fdb4563f1acb0ff8b978493bfd2bc1c
├── <span class="token number">21</span>
│   └── 6ef921a90b782fed1ca37223c3141ed7d5de32
├── 2a
│   └── a80fc99a89a808fc0342972c5a3514d41fa5f7
├── <span class="token number">33</span>
│   └── ad99f76f295411d5c198cb58c5c95e5d0b3c91
├── 3a
│   └── a1317953001375c744a8a12f59a37cc1640fdb
├── 6f
│   └── e402b35d6e80a187adc393f36ce10e4fdd259f
├── <span class="token number">77</span>
│   └── e9ad8de018dab58d76e0667507378b3cfe4808
├── bd
│   └── c5642cd9e8a62767710d1d9761b056f91f094c
├── d3
│   └── 827e75a5cadb9fe4a27e1cb9b6d192e7323120
├── info
└── pack

<span class="token number">11</span> directories, <span class="token number">9</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p>创建成功 commit 对象后，很快我们就会发现一个问题：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log
fatal: your current branch <span class="token string">'master'</span> does not have any commits yet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>前面查看 log 时指定了 commit ID 才有结果，但是如果不指定 commit，系统就提示当前分支没有 commit，这是怎么回事？我们平时都是没指定也能正常使用对吧。</p>
<p>原因是还有些工作没有完成，这就涉及到Git引用(<code>Git Reference</code>)。</p>
<p>在 <code>local_a</code> 仓库中，目前我们还没有创建任何引用，所以 <code>.git/refs</code> 下面还是空的：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">find</span> .git/refs
.git/refs
.git/refs/tags
.git/refs/heads
$ <span class="token function">find</span> .git/refs -type f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们还是继续手动创建。</p>
<p>首先我们需要一个指向当前分支（默认master）最新提交(bdc56)的引用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> bdc5642cd9e8a62767710d1d9761b056f91f094c <span class="token operator">></span> .git/refs/heads/master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此时，再次运行 <code>git log</code>，不需要指定 commit ID 就能看到全部提交历史了。</p>
<p>实际上 git 有专门的命令完成引用设置：git-update-ref</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> update-ref refs/heads/master bdc5642cd9e8a62767710d1d9761b056f91f094c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>基于引用，于是就有了分支的实现。实际上每个分支都有一个 head 指针，指向该分支的最新提交。</p>
<p>假设我们在第二次提交(<code>2aa80fc99a89a808fc0342972c5a3514d41fa5f7</code>)上切出一个分支，实际上就是加一个引用名，如 <code>dev</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> update-ref refs/heads/dev 2aa80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>git log</code> 可以看到第二次提交上有个 <code>dev</code> 的标签，运行 <code>git branch</code> 也可以看到有 dev 分支。</p>
<p>通过 <code>git log</code>可以看到有个特殊的指针HEAD，它是指向引用的引用，它永远指向当前分支。</p>
<p>当前分支在 <code>master</code> 分支上，所以HEAD指向 <code>master</code>，当使用 <code>git checkout dev</code> 后可以看到HEAD指向 <code>dev</code>, 表示当前切换到了 <code>dev</code> 分支。</p>
<p>HEAD是一种符号引用(symbolic reference)</p>
<p>git 有个专门的命令用来读取，修改，删除符号引用：<code>git symbolic-ref</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> symbolic-ref HEAD
refs/heads/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>表示当前分支是master</p>
</blockquote>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> symbolic-ref HEAD refs/heads/dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>改变HEAD的指向, 也意味着切换分支</p>
</blockquote>
<hr>
<h3 id="认识tag-object"><strong>认识tag object</strong></h3>
<p>其实还有一种比较少用到的 Git 数据对象是 <strong>tag object</strong>，它和 commit 对象有点类似，创建方式是:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag -a tag-name -m <span class="token string">"tag message"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>比如我们创建一个 <code>v1.0</code> 的 <code>tag</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag -a v1.0 -m <span class="token string">"version 1.0"</span>

$ <span class="token function">cat</span> .git/refs/tags/v1.0
05f749dc5667010dbe07ee181b3607143b84b14f
$ <span class="token function">git</span> cat-file -t 05f749dc5667010dbe07ee181b3607143b84b14f
tag
$ <span class="token function">git</span> cat-file -p 05f749dc5667010dbe07ee181b3607143b84b14f
object bdc5642cd9e8a62767710d1d9761b056f91f094c
<span class="token builtin class-name">type</span> commit
tag v1.0
tagger Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span> <span class="token number">1629103432</span> +0800

version <span class="token number">1.0</span>

<span class="token comment"># 或者</span>
$ <span class="token function">git</span> cat-file -t v1.0
tag

$ <span class="token function">git</span> cat-file -p v1.0
object bdc5642cd9e8a62767710d1d9761b056f91f094c
<span class="token builtin class-name">type</span> commit
tag v1.0
tagger Li Linchao <span class="token operator">&lt;</span>lilinchao@oschina.cn<span class="token operator">></span> <span class="token number">1629103432</span> +0800

version <span class="token number">1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>git tag</code> 的 hash 值在 <code>.git/refs/tags/v1.0</code> 文件里面。v1.0 是文件名，也是 tag 名称，文件内容是 tag 的 hash 值，它们一一对应，v1.0 就是 <code>db1cc3710e8b284f44286400b61974a8f1e633d4</code> 的指针。</p>
<p>我们可以借助 <code>git-draw</code> 工具生成一张图来说明此时的仓库各个数据之间的关系：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token punctuation">..</span>/git-draw -i --hide-index --hide-legend --hide-reflogs --hide-refs --image-filename output.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>工具地址:  <a href="https://github.com/sensorflo/git-draw">https://github.com/sensorflo/git-draw</a></p>
</blockquote>
<p>或者手动绘制各种数据的关系，如下：<br>
<img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/20220831112729.png" alt=""></p>
<blockquote>
<p><a href="http://assets.processon.com/chart_image/60a12b2fe0b34d34ca5ef5e7.png">http://assets.processon.com/chart_image/60a12b2fe0b34d34ca5ef5e7.png</a></p>
</blockquote>
<h3 id="参考">参考</h3>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1">Git 内部原理 - Git 对象</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%BC%95%E7%94%A8">Git 内部原理 - Git 引用</a></p>
<p><a href="https://morningspace.github.io/tech/inside-git-1/">认识Git对象</a></p>
<p><a href="https://morningspace.github.io/tech/inside-git-3/">认识Git引用</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git-inside</tag>
      </tags>
  </entry>
</search>
