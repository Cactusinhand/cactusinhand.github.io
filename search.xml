<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Design pattern in Gitlay(Git PRC service)</title>
    <url>/posts/341c748.html</url>
    <content><![CDATA[<p>这篇文章源于偶然看到的一篇文章<a href="https://studygolang.com/articles/29501"># Golang技巧之默认值设置的高阶玩法</a>，它讲的是 GRPC 中的设计模式。而我没有研究过 GRPC 源码，看起来稍显陌生。但好在手头上有 Gitaly 源码，算是稍微熟悉它的源码，因此想看看这个项目里面是不是也应用到了前面文章里讲的高阶用法，简单搜索一下源码后，发现这种代码模式还挺多的，于是趁热记录了其中一小段阅读结果。</p>
<span id="more"></span>
<blockquote>
<p>Gitaly is a Git RPC service for handling all the git calls made by GitLab<br>
repo: gitaly: <a href="https://gitlab.com/gitlab-org/gitaly">https://gitlab.com/gitlab-org/gitaly</a></p>
</blockquote>
<p><code>git rev-list</code> 是 Git 中非常重要和有用的命令，它存在许多选项以及子命令，Gitaly 中对这些选项和命令进行了封装。</p>
<p>首先定义了一个 config 结构体，包含不同的配置选项：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ObjectType <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> revlistConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    blobLimit     <span class="type">int</span></span><br><span class="line">    objects       <span class="type">bool</span></span><br><span class="line">    objectType    ObjectType</span><br><span class="line">    order         Order</span><br><span class="line">    reverse       <span class="type">bool</span></span><br><span class="line">    maxParents    <span class="type">uint</span></span><br><span class="line">    disabledWalk  <span class="type">bool</span></span><br><span class="line">    firstParent   <span class="type">bool</span></span><br><span class="line">    before, after time.Time</span><br><span class="line">    author        []<span class="type">byte</span></span><br><span class="line">    skipResult    <span class="function"><span class="keyword">func</span><span class="params">(*RevisionResult)</span></span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义一个函数，该函数的参数是上述结构体，且是指针类型参数，这点非常重要，它使得这个函数能够直接修改入参 <code>cfg</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RevlistOption <span class="function"><span class="keyword">func</span><span class="params">(cfg *revlistConfig)</span></span></span><br></pre></td></tr></table></figure>
<p>然后是一系列对 git-rev-list 参数进行修改的方法，每个 <code>WithXXX</code> 方法调用前面的匿名函数，并返回 RevlistOption 类型变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithBlobLimit</span><span class="params">(limit <span class="type">int</span>)</span></span> RevlistOption &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *revlistConfig)</span></span> &#123;</span><br><span class="line">        cfg.blobLimit = limit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithObjectTypeFilter</span><span class="params">(t ObjectType)</span></span> RevlistOption &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *revlistConfig)</span></span> &#123;</span><br><span class="line">        cfg.objectType = t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRevrse</span><span class="params">()</span></span> RevlistOption &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *revlistConfig)</span></span> &#123;</span><br><span class="line">        cfg.reverse = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMaxParents</span><span class="params">(p <span class="type">uint</span>)</span></span> RevlistOption &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *revlistConfig)</span></span> &#123;</span><br><span class="line">        cfg.maxParents = p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDisabledWalk</span><span class="params">()</span></span> RevlistOption &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *revlistConfig)</span></span> &#123;</span><br><span class="line">        cfg.disabledWalk = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithFirstParent</span><span class="params">()</span></span> RevlistOption &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *revlistConfig)</span></span> &#123;</span><br><span class="line">        cfg.firstParent = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithBefore</span><span class="params">(t time.Time)</span></span> RevlistOption &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *revlistConfig)</span></span> &#123;</span><br><span class="line">        cfg.before = t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithAfter</span><span class="params">(t time.Time)</span></span> RevlistOption &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *revlistConfig)</span></span> &#123;</span><br><span class="line">        cfg.after = t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithAuthor</span><span class="params">(author []<span class="type">byte</span>)</span></span> RevlistOption &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *revlistConfig)</span></span> &#123;</span><br><span class="line">        cfg.author = author</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略...</span></span><br></pre></td></tr></table></figure>
<p>git-rev-list 方法定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Revlist</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ctx context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">    repo *localrepo.Repo,</span></span></span><br><span class="line"><span class="params"><span class="function">    revisions []<span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    options ...RevlistOption,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> RevisionIterator</span><br></pre></td></tr></table></figure>
<p>在 Revlist() 中最后一个参数 <code>options ...RevlistOption</code>，它表示是不定长变参列表具体参数数量交给调用者。</p>
<p>具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Revlist</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ctx context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">    repo *localrepo.Repo,</span></span></span><br><span class="line"><span class="params"><span class="function">    revisions []<span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    options ...RevlistOption,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> RevisionIterator &#123;</span><br><span class="line">    <span class="comment">// 定义一个config配置变量</span></span><br><span class="line">    <span class="keyword">var</span> cfg revlistConfig</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里，遍历options中每一个方法，每个方法都会对config变量进行赋值、修改</span></span><br><span class="line">    <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">        option(&amp;cfg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resultChan := <span class="built_in">make</span>(<span class="keyword">chan</span> RevisionResult)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用goroutine丢到后台运行</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(resultChan)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义git option变量flags</span></span><br><span class="line">        flags := []git.Option&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面几项都是根据cfg配置, 更新flag变量</span></span><br><span class="line">        <span class="keyword">if</span> cfg.objects &#123;</span><br><span class="line">            flags = <span class="built_in">append</span>(flags,</span><br><span class="line">                git.Flag&#123;Name: <span class="string">&quot;--in-commit-order&quot;</span>&#125;,</span><br><span class="line">                git.Flag&#123;Name: <span class="string">&quot;--objects&quot;</span>&#125;,</span><br><span class="line">                git.Flag&#123;Name: <span class="string">&quot;--object-names&quot;</span>&#125;,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cfg.blobLimit &gt; <span class="number">0</span> &#123;</span><br><span class="line">            flags = <span class="built_in">append</span>(flags, git.Flag&#123;</span><br><span class="line">                Name: fmt.Sprintf(<span class="string">&quot;--filter=blob:limit=%d&quot;</span>, cfg.blobLimit),</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cfg.objectType != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            flags = <span class="built_in">append</span>(flags,</span><br><span class="line">                git.Flag&#123;Name: fmt.Sprintf(<span class="string">&quot;--filter=object:type=%s&quot;</span>, cfg.objectType)&#125;,</span><br><span class="line">                git.Flag&#123;Name: <span class="string">&quot;--filter-provided-objects&quot;</span>&#125;,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 此处省略更多项cfg配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置完成后，执行git-rev-list命令</span></span><br><span class="line">        <span class="keyword">var</span> stderr strings.Builder</span><br><span class="line">        revlist, err := repo.Exec(ctx,</span><br><span class="line">            git.SubCmd&#123;</span><br><span class="line">                Name:  <span class="string">&quot;rev-list&quot;</span>,</span><br><span class="line">                Flags: flags,</span><br><span class="line">                Args:  revisions,</span><br><span class="line">            &#125;,</span><br><span class="line">            git.WithStderr(&amp;stderr),</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 此处省略错误处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对结果的每行进行处理</span></span><br><span class="line">        scanner := bufio.NewScanner(revlist)</span><br><span class="line">        <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">            line := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(scanner.Bytes()))</span><br><span class="line">            <span class="built_in">copy</span>(line, scanner.Bytes())</span><br><span class="line"></span><br><span class="line">            oidAndName := bytes.SplitN(line, []<span class="type">byte</span>&#123;<span class="string">&#x27; &#x27;</span>&#125;, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            result := RevisionResult&#123;</span><br><span class="line">                OID: git.ObjectID(oidAndName[<span class="number">0</span>]),</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略...</span></span><br><span class="line">            <span class="keyword">if</span> isDone := sendRevisionResult(ctx, resultChan, result); isDone &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// scan结束</span></span><br><span class="line">        <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            sendRevisionResult(ctx, resultChan, RevisionResult&#123;</span><br><span class="line">                err: fmt.Errorf(<span class="string">&quot;scanning rev-list output: %w&quot;</span>, err),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待goruntine结束</span></span><br><span class="line">        <span class="keyword">if</span> err := revlist.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            sendRevisionResult(ctx, resultChan, RevisionResult&#123;</span><br><span class="line">                err: fmt.Errorf(<span class="string">&quot;rev-list pipeline command: %w, stderr: %q&quot;</span>, err, stderr.String()),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> &amp;revisionIterator&#123;</span><br><span class="line">        ch: resultChan,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如何调用这个方法呢？搜索 Gitaly 源码可以看到：</p>
<p>在<code>ListBlobs</code> 中是这样用的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> ListBlobs(req *gitalypb.ListBlobsRequest, stream gitalypb.BlobService_ListBlobsServer) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个RevlistOption变量，向里面注入多个配置选项</span></span><br><span class="line">    revlistOptions := []gitpipe.RevlistOption&#123;</span><br><span class="line">        gitpipe.WithObjects(),</span><br><span class="line">        gitpipe.WithObjectTypeFilter(gitpipe.ObjectTypeBlob),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Revlist()</span></span><br><span class="line">    revlistIter := gitpipe.Revlist(ctx, repo, req.GetRevisions(), revlistOptions...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ListCommits</code> 中根据请求中不同的 case 分别向 revlistOptions 变量追加不同的配置选项：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> ListCommits(</span><br><span class="line">    request *gitalypb.ListCommitsRequest,</span><br><span class="line">    stream gitalypb.CommitService_ListCommitsServer,</span><br><span class="line">) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    ctx := stream.Context()</span><br><span class="line">    repo := s.localrepo(request.GetRepository())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个revlistOptions变量</span></span><br><span class="line">    revlistOptions := []gitpipe.RevlistOption&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 根据不同的case向revlistOptions追加不同的配置</span></span><br><span class="line">    <span class="keyword">if</span> request.GetReverse() &#123;</span><br><span class="line">        revlistOptions = <span class="built_in">append</span>(revlistOptions, gitpipe.WithReverse())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.GetMaxParents() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        revlistOptions = <span class="built_in">append</span>(revlistOptions, gitpipe.WithMaxParents(<span class="type">uint</span>(request.GetMaxParents())))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.GetDisableWalk() &#123;</span><br><span class="line">        revlistOptions = <span class="built_in">append</span>(revlistOptions, gitpipe.WithDisabledWalk())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.GetFirstParent() &#123;</span><br><span class="line">        revlistOptions = <span class="built_in">append</span>(revlistOptions, gitpipe.WithFirstParent())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.GetBefore() != <span class="literal">nil</span> &#123;</span><br><span class="line">        revlistOptions = <span class="built_in">append</span>(revlistOptions, gitpipe.WithBefore(request.GetBefore().AsTime()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.GetAfter() != <span class="literal">nil</span> &#123;</span><br><span class="line">        revlistOptions = <span class="built_in">append</span>(revlistOptions, gitpipe.WithAfter(request.GetAfter().AsTime()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.GetAuthor()) != <span class="number">0</span> &#123;</span><br><span class="line">        revlistOptions = <span class="built_in">append</span>(revlistOptions, gitpipe.WithAuthor(request.GetAuthor()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用Revlist()</span></span><br><span class="line">    revlistIter := gitpipe.Revlist(ctx, repo, request.GetRevisions(), revlistOptions...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略后续...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ListLFSPointers</code> 中省略定义 RevlistOption 变量，直接利用 Revlist 方法中不定参数特性，添加不同的配置选项：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> ListLFSPointers(in *gitalypb.ListLFSPointersRequest, stream gitalypb.BlobService_ListLFSPointersServer) <span class="type">error</span> &#123;</span><br><span class="line">    ctx := stream.Context()</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    repo := s.localrepo(in.GetRepository())</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Revlist()</span></span><br><span class="line">    revlistIter := gitpipe.Revlist(ctx, repo, in.GetRevisions(),</span><br><span class="line">        gitpipe.WithObjects(),</span><br><span class="line">        gitpipe.WithBlobLimit(lfsPointerMaxSize),</span><br><span class="line">        gitpipe.WithObjectTypeFilter(gitpipe.ObjectTypeBlob),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">/// 省略后续...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>这种设计模式对于多配置，多参数的方法非常适合，虽然代码实现起来有点麻烦，但是可读性强，使用灵活。这种模式还有一些变体，后面有时间再记录一下。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Design-Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>一种 Git 插件工具：git repo-clean</title>
    <url>/posts/92e91caf.html</url>
    <content><![CDATA[<p>本篇文章将从如何定义 Git 大仓库，大仓库如何产生，大仓库的负面影响等方面讨论起，然后介绍几款目前针对大仓库的处理工具，并讨论它们的优缺点，然后谈谈我们今天要介绍的新工具<strong>git repo-clean</strong>的一些设计目标，并重点介绍它的设计原理。</p>
<span id="more"></span>
<p>作为国内最大的代码托管平台，Gitee 每天都有大量不同行业的人在上面围绕 Git 仓库进行各种 Git 操作实践。</p>
<p>但是我们经常收到用户的帮助请求，他们的问题往往是其 Git 仓库变得非常大，这影响了他们对仓库做进一步的操作，甚至会导致开发进度落后。</p>
<h5 id="实际场景：">实际场景：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>场景一：</strong></p>
<p>用户不小心使用 <code>git add .</code> 将当前工作区中的所有文件加入到 Git 仓库，并做了提交，但是后来意识到有些文件并不是想要的，如 <code>build/</code>、<code>ThirdPart/</code>、<code>vendor/</code>等目录下的文件，于是想删除掉之前的提交中的部分文件。一般情况下，可以使用 <code>git reset</code>或者 <code>git revert</code>回退当前的 <code>bad commit</code>到它的前一次 <code>commit</code>。但是，由于已经提交了很多正常的有用的 <code>commit</code>，这个时候再回退就需要小心了，因为所有 <code>bad commit</code> 之后的所有正常提交也会被回退。</p>
</li>
<li class="lvl-2">
<p><strong>场景二：</strong></p>
<p>在一个成熟的项目中经过多年的迭代，项目的功能变得与以前非常不同，不断地代码迭代也使得 Git 仓库变得臃肿，再加上在用 Git 管理项目的前期由于使用的不成熟，向仓库提交了很多不必要的文件，这些文件长期存在，而且如果对一个大文件进行过多次修改，每个版本都会完整保存在仓库中，则体积也会成倍增长。之后推送到服务端仓库，也会占用相当大的服务端仓库资源。同时，在协作开发的情况下，意味着每个人都会克隆一个巨大的仓库到本地，而且由于数据量很大，该过程变得很慢。</p>
</li>
</ul>
<h5 id="问题：">问题：</h5>
<p>基于以上场景，可以归纳出 Git 仓库的几种常见的问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>向仓库中提交了大量不必要的文件。如：项目编译过程文件，第三方库文件，多媒体文件等。这导致 Git 仓库的提交文件被污染。</p>
</li>
<li class="lvl-2">
<p>向仓库中提交的单个文件非常大。假如提交了一个 100M 的文件，一方面平台会限制用户推送单个文件大小超过 100M 的文件；另一方面，如果多次修改过这个文件，仓库中将会存在多个版本，比如经过10次修改，每个版本大约还是 100M，那仓库就会因为这个文件，体积变为 <code>10 * 100M</code>，这样仓库总的大小也会变得巨大，也将超过推送限额。</p>
</li>
</ul>
<p>以上都属于是 Git 大仓库问题，根据经验法则，大仓库的衡量维度包括：</p>
<ol>
<li class="lvl-3">
<p>单个文件是否过大</p>
</li>
<li class="lvl-3">
<p>文件数量是否过多, 如数量超过100k</p>
</li>
<li class="lvl-3">
<p>提交数量是否过多，如数量超过100K</p>
</li>
<li class="lvl-3">
<p>分支数/标签数是否过多，如数量超过10K</p>
</li>
<li class="lvl-3">
<p>子模块是否过多，如超过25个子模块</p>
</li>
</ol>
<blockquote>
<p>关于 Git 大仓库的详细说明，可见这篇文章[<a href="https://gitee.com/cactusinhand/all-about-git/blob/master/doc/large-git-repos-zh.md">1]</a>。</p>
</blockquote>
<p>以上衡量标准并不是固定的，只是根据经验所得，是一种参考值，其衡量值往往随着电脑的性能，系统的类型，以及Git 的版本不同而不同。</p>
<p>但是根据这种衡量标准，我们大致能知道怎么样的仓库才算得上大仓库。</p>
<p>我们收到的大仓库问题反馈一般集中在前两种。通常，当出现仓库数据过大的信号后，用户一开始往往会选择删除仓库当前工作区下的文件，而忽略了 Git 仓库是分为工作区，缓存区，对象存储区的结构。当文件提交后，不仅工作区存在该文件，对象存储区也存在该文件，所以只删除工作区的文件，虽然肉眼看不见文件了，但其实它还是存在仓库中，通过一些git命令很容易将它恢复到当前工作区。这说明仓库体积并没用有效的减少。</p>
<p>一方面，Git 是生来是为源代码文件而设计和优化的，而源代码文件一般都不会很大，对于大仓库，Git 的很多操作的性能产生非常大的影响，如果大仓库中问非常多，那么在有遍历操作的git命令的时候就非常耗时；另一方面，Git 是分布式的，一个仓库通常包含所有的修改版本、提交历史。大仓库的数据存储和传输会有一定压力，比如传输很慢，传输超时，或者存储空间不足导致传输失败等。</p>
<p>我们很多时候很难避免制造Git大仓库，所以这些问题很容易出现。对Git的操作比较熟悉的人，会在项目刚开始的时候，通过<code>.gitignore</code> 文件[<a href="https://git-scm.com/docs/gitignore">2]</a>来管理提交到仓库的文件。</p>
<p>在Gitee上新建仓库时，也会提供<code>.gitignore</code>模板文件:</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/gitee_gitignore.png" alt=""></p>
<p>如果仓库中没有这个文件，需要手动新建。</p>
<p>这个文件的作用是将指定类型，或者指定目录下的文件忽视掉，Git就不会将这些文件加入到仓库中，从而保持仓库干净。</p>
<p>使用<code>.gitignore</code>管理仓库文件只是防止仓库污染、体积膨胀的手段之一。</p>
<p>另外一种手段是使用<code>Git LFS</code> 专门来管理仓库大文件，从而避免仓库体积膨胀。</p>
<p>该功能的原理是，使用专门的大文件存储服务器来管理仓库中特定的大文件，而本地仓库只管理大文件的指针。详情可参考：Git LFS 操作指南[<a href="https://gitee.com/help/articles/4235">3]</a>。</p>
<p>如果是仓库中已经存在大量非必要大文件而导致仓库体积膨胀，那么如何解决呢？其实已经有人做出了一些工具，来试图解决此类问题。</p>
<p>我们先来看下几种常见的工具的对比：</p>
<h5 id="同类工具对比：">同类工具对比：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>git-filter-branch[<a href="https://git-scm.com/docs/git-filter-branch">4]</a></p>
</li>
</ul>
<p>特点：</p>
<p>Git 内部自带的命令，只要有 Git 环境，就能使用这个工具。</p>
<p><strong>使用示例：</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git <span class="keyword">filter</span><span class="literal">-branch</span> <span class="literal">--tree-filter</span> <span class="string">&#x27;rm -f path/to/large/file&#x27;</span> <span class="literal">--tag-name-filter</span> <span class="built_in">cat</span> <span class="literal">--</span> <span class="literal">--all</span></span><br><span class="line"><span class="variable">$</span> git reflog expire <span class="literal">--expire</span>=now <span class="literal">--all</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">gc</span> <span class="literal">--prune</span>=now <span class="literal">--aggressive</span></span><br><span class="line"><span class="variable">$</span> git push origin <span class="literal">--tags</span> <span class="literal">--force</span></span><br><span class="line"><span class="variable">$</span> git push origin <span class="literal">--all</span> <span class="literal">--force</span></span><br></pre></td></tr></table></figure>
<p><strong>问题：</strong></p>
<ol>
<li class="lvl-3">
<p>使用起来比较复杂；</p>
</li>
<li class="lvl-3">
<p>如果不确定大文件，需要先使用其它命令手动扫描仓库中存在的大文件；</p>
</li>
<li class="lvl-3">
<p>处理过程特别慢[<a href="https://git-scm.com/docs/git-filter-branch#PERFORMANCE">5]</a>!；</p>
</li>
<li class="lvl-3">
<p>如果存在特殊文件名，特殊文件路径，可能会出错，甚至误删文件；</p>
</li>
<li class="lvl-3">
<p>删除文件、重写历史之后，可能旧的和新的历史记录都存在，导致仓库体积反而变大[<a href="https://git-scm.com/docs/git-filter-branch#SAFETY">6]</a>。</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>git-filter-repo[<a href="https://github.com/newren/git-filter-repo">7]</a></p>
</li>
</ul>
<p><strong>特点：</strong></p>
<p>git filter-branch 的官方替代，官方推荐使用该工具来代替原生 <code>git-filter-branch</code> 命令。</p>
<p>速度快，功能多，使用灵活。</p>
<p><strong>使用示例：</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git <span class="keyword">filter</span><span class="literal">-repo</span> <span class="literal">--path</span> bigfile.zip <span class="literal">--path</span> big/files/<span class="built_in">dir</span>/ <span class="literal">--invert-paths</span></span><br><span class="line"><span class="variable">$</span> git push origin <span class="literal">--tags</span> <span class="literal">--force</span></span><br><span class="line"><span class="variable">$</span> git push origin <span class="literal">--all</span> <span class="literal">--force</span></span><br></pre></td></tr></table></figure>
<p><strong>问题：</strong></p>
<ol>
<li class="lvl-3">
<p>需要删除的文件可能不在当前工作区，而是在历史提交中，用户无法直接提供文件名、文件 ID 进行删除；</p>
</li>
<li class="lvl-3">
<p>依赖 Python 环境。</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>BFG Repo-Cleaner[<a href="https://github.com/rtyley/bfg-repo-cleaner">8]</a></p>
</li>
</ul>
<p><strong>特点：</strong></p>
<p>速度快，使用比较简单。</p>
<p><strong>使用示例：</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> java <span class="literal">-jar</span> bfg.jar <span class="literal">--strip-blobs-bigger-than</span> <span class="number">100</span>M my<span class="literal">-big-repo</span>.git</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> my<span class="literal">-big-repo</span>.git</span><br><span class="line"><span class="variable">$</span> git reflog expire <span class="literal">--expire</span>=now <span class="literal">--all</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">gc</span> <span class="literal">--prune</span>=now <span class="literal">--aggressive</span></span><br><span class="line"><span class="variable">$</span> git push origin <span class="literal">--tags</span> <span class="literal">--force</span></span><br><span class="line"><span class="variable">$</span> git push origin <span class="literal">--all</span> <span class="literal">--force</span></span><br></pre></td></tr></table></figure>
<p><strong>问题：</strong></p>
<ol>
<li class="lvl-3">
<p>不会处理最新的 commit(HEAD commit)；</p>
</li>
<li class="lvl-3">
<p>会在所有被处理的 commit 信息中加入额外的信息。如：<code>Former-commit-id: xxxxx</code>，特别是如果多次运行该命令，则会在这些 commit 中加入多条额外信息，这会污染commit信息；</p>
</li>
<li class="lvl-3">
<p>处理之后会在 HEAD commit 中加入很多额外信息；</p>
</li>
<li class="lvl-3">
<p>对松散对象没有做处理；如果松散对象是要删除的大文件，则不会成功；</p>
</li>
<li class="lvl-3">
<p>需要额外手动进行 GC 操作；</p>
</li>
<li class="lvl-3">
<p>依赖 Java 环境。</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>git-siezer[<a href="https://github.com/github/git-sizer">9]</a></p>
</li>
</ul>
<p><strong>特点：</strong></p>
<p>对 Git 仓库中的数据指标进行详细的统计。</p>
<p><strong>使用实例：</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git sizer  <span class="literal">--threshold</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>问题：</strong></p>
<ol>
<li class="lvl-3">
<p>只是对仓库的数据信息做概括统计。如：总的 commit 数量，总的文件(blob)数量，最大的单个文件等，不能告诉用户最大的 N 个文件，不能进行文件删除、历史重写。</p>
</li>
</ol>
<h5 id="git-repo-clean-设计目标：">git-repo-clean 设计目标：</h5>
<p>通过对以上工具的特点、问题进行总结，我们试图开发出一款工具，解决以下问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>纯命令行方式对有些用户不太友好，并且使用说明都是英文，阅读英文使用文档比较困难</p>
</li>
<li class="lvl-2">
<p>没有自动对仓库进行备份，由于可能误操作，丢失仓库数据</p>
</li>
<li class="lvl-2">
<p>对仓库历史文件不太了解，无法准确知道需要删除哪些文件</p>
</li>
<li class="lvl-2">
<p>删除过程太慢。</p>
</li>
</ul>
<p>这款工具就是：<code>git-repo-clean</code>[<a href="https://gitee.com/oschina/git-repo-clean">10]</a>。</p>
<p>总的来说，<code>git-repo-clean</code> 具备以下<strong>优势</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用简单。支持交互模式，用户操作起来比单纯的命令行方式更简单。</p>
</li>
<li class="lvl-2">
<p>支持扫描模式。当对历史提交文件不太了解时，可以选择先扫描仓库，只需提供文件类型、大小、数量即可扫描出目标历史文件，再进行删除(交互模式下，也会使用扫描模式)，弥补了 <code>git-filter-branch</code>的缺点。</p>
</li>
<li class="lvl-2">
<p>支持直接指定文件进行删除。</p>
</li>
<li class="lvl-2">
<p>支持删除指定目录下的所有文件(包括目录本身)，及其提交记录。</p>
</li>
<li class="lvl-2">
<p>速度快。从 <code>v1.2.0</code> 开始，<code>git-repo-clean</code>的速度可以达到与 <code>git-filter-repo</code> 同级别速度。</p>
</li>
<li class="lvl-2">
<p>无其它依赖。源码使用 Golang 实现，通过交叉编译，最终可执行程序可在多平台兼容，不需要依赖特定的语言环境。</p>
</li>
<li class="lvl-2">
<p>本地化。有中文文档，软件使用界面支持本地化。</p>
</li>
</ul>
<h5 id="git-repo-clean-技术原理：">git-repo-clean 技术原理：</h5>
<p>一般来说，我们要创建一个 Git 仓库，需要以下操作：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git init mini<span class="literal">-repo</span> &amp;&amp; <span class="built_in">cd</span> mini<span class="literal">-repo</span></span><br><span class="line"><span class="variable">$</span> touch README &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;first file in repo&quot;</span> &gt; README</span><br><span class="line"><span class="variable">$</span> git add README &amp;&amp; git commit <span class="literal">-m</span> <span class="string">&quot;init commit&quot;</span></span><br></pre></td></tr></table></figure>
<p>Git 内部提供了两个命令: <code>git-fast-export</code>, <code>git-fast-import</code>， 他们分别的作用是将 Git 仓库数据(.git/objects)导出为特定格式的 <code>元数据</code>，然后流式读取这种特定格式的元数据，于是就成一个完整的 Git 仓库。</p>
<p>任何符合格式的完整的元数据，输入给 <code>git-fast-import</code> 都能创建一个 Git 仓库。</p>
<p>我们先来看下一组最小完整的 Git 元数据：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">blob</span>    <span class="comment"># blob类型，即文件</span></span><br><span class="line"><span class="string">mark</span> <span class="string">:1</span> <span class="comment"># 标号1</span></span><br><span class="line"><span class="string">data</span> <span class="number">32</span> <span class="comment"># 文件大小</span></span><br><span class="line"><span class="attr">FILE:</span> <span class="string">this</span> <span class="string">is</span> <span class="string">the</span> <span class="string">file</span> <span class="string">content.</span> <span class="comment"># 文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="string">reset</span> <span class="string">refs/heads/master</span>  <span class="comment"># 分支</span></span><br><span class="line"><span class="string">commit</span> <span class="string">refs/heads/master</span> <span class="comment"># commit指向的分支</span></span><br><span class="line"><span class="string">mark</span> <span class="string">:2</span> <span class="comment"># 标号2</span></span><br><span class="line"><span class="string">author</span> <span class="string">Li</span> <span class="string">Linchao</span> <span class="string">&lt;lilinchao@oschina.cn&gt;</span> <span class="number">1633749750</span> <span class="string">+0800</span>        <span class="comment"># commit作者</span></span><br><span class="line"><span class="string">committer</span> <span class="string">Li</span> <span class="string">Linchao</span> <span class="string">&lt;lilinchao@oschina.cn&gt;</span> <span class="number">1633749750</span> <span class="string">+0800</span>     <span class="comment"># commit提交者</span></span><br><span class="line"><span class="string">data</span> <span class="number">65</span>                                                          <span class="comment"># commit信息大小</span></span><br><span class="line"><span class="attr">COMMIT:</span> <span class="string">this</span> <span class="string">is</span> <span class="string">the</span> <span class="string">commit</span> <span class="string">message.</span> <span class="string">The</span> <span class="string">file</span> <span class="string">name</span> <span class="string">will</span> <span class="string">be</span> <span class="string">README</span> <span class="comment"># commit信息</span></span><br><span class="line"><span class="string">M</span> <span class="number">100644</span> <span class="string">:1</span> <span class="string">README</span>                          <span class="comment"># commit修改的文件，相当于tree,即文件名</span></span><br><span class="line"><span class="comment"># M表示修改modify(新增也是修改)，100644表示文件类型，1表示指向标号为1的blob，README表示blob标号为1的文件名</span></span><br></pre></td></tr></table></figure>
<p>通过这组元数据，使用 <code>git fast-import</code> 命令，就能创建出一个完整的仓库，里面包含:</p>
<ol>
<li class="lvl-3">
<p>一个文件，文件大小是 32 Bytes, 内容是：<code>FILE: this is the file content.</code></p>
</li>
<li class="lvl-3">
<p>一个分支，分支名为 <code>master</code></p>
</li>
<li class="lvl-3">
<p>一个 commit 提交，表示对 README 文件的修改。提交信息是：<code>COMMIT: this is the commit message. The file name will be README</code></p>
</li>
</ol>
<p>口说无凭，我们来看下这组元数据实际怎么生成一个完整 Git 仓库的。</p>
<p>首先需要在一个空的 Git 仓库中进行操作，然后将上述元数据输入到 <code>git fast-import</code> 中。</p>
<p>假设上述元数据存放在文件 <code>meatadata</code> 中。</p>
<p>接下来，具体操作如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git init fake<span class="literal">-repo</span> &amp;&amp; <span class="built_in">cd</span> fake<span class="literal">-repo</span></span><br><span class="line"><span class="variable">$</span> git fast<span class="literal">-import</span> <span class="literal">--force</span> <span class="literal">--quiet</span> <span class="literal">--date-format</span>=raw<span class="literal">-permissive</span> &lt; ../metadata</span><br><span class="line"><span class="variable">$</span> git reset <span class="literal">--hard</span> HEAD <span class="comment"># 清除缓存区，和工作区，回到最新的commit上</span></span><br></pre></td></tr></table></figure>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/init_git_repo.png" alt=""></p>
<p>成功之后，刚创建的新仓库 <code>fake-repo</code> 下就有了一个 README 文件，一个 commit 提交，一个 master 分支：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_commit.png" alt=""></p>
<p>README 文件信息和 commit 信息都是根据元数据 <code>metadata</code> 中的定义而来，我们可以任意修改。</p>
<p>可以说，Git 元数据是对 Git 仓库中的底层数据(blob, tree, commit, tag)进行结构化表示。</p>
<p>那么，如果我们想对一个现存的 Git 仓库进行有目的修改，可以先获得该仓库的元数据，然后进行相应操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何获得一个 Git 仓库的元数据呢？</span><br></pre></td></tr></table></figure>
<p>那就是前面提到的 <code>git fast-export</code> 命令。</p>
<p><code>git fast-export</code> 命令可以接受很多参数，比如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>--show-original-ids</code> 用于在输出中加入每个数据类型的原始 hash ID, 这个对于重写 commit 历史，或者通过 ID 裁剪 blob 有帮助。</p>
</li>
<li class="lvl-2">
<p><code>--reencode=(yes|no|abort)</code> 用于处理 commit 信息中的编码问题， yes 表示将 commit message 重新编码为 <code>UTF-8</code>。</p>
</li>
<li class="lvl-2">
<p><code>--no-data</code> 会在输出中省略 <code>blob</code> 类型数据。</p>
</li>
</ul>
<p>具体应该使用什么参数，可以根据修改的目的来调整。</p>
<p>例如， 使用<code>--show-original-ids</code>, <code>--reencode</code>, <code>--use-done-feature</code>,<code> --all</code> 选项时的输出如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_fast_export.png" alt=""></p>
<p>到目前为止，我们已经知道如何获取仓库元数据，也知道怎么根据元数据生成一个新的仓库，那么如果我们想要对仓库进行修改，只需要在这个过程中进行<strong>元数据过滤</strong>即可。</p>
<p>所以 <code>git-clean-repo</code> 的大致流程如下：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">git-fast-export</span><br><span class="line">     |<span class="string"></span></span><br><span class="line"><span class="string">     </span>|<span class="string"> output stream</span></span><br><span class="line"><span class="string">     V</span></span><br><span class="line"><span class="string">     ---&gt; parser(blob, tree, commit...)</span></span><br><span class="line"><span class="string">             </span>|</span><br><span class="line">             |<span class="string"></span></span><br><span class="line"><span class="string">             V</span></span><br><span class="line"><span class="string">             ----&gt; filter(blob size, blob id, blob diectory...)</span></span><br><span class="line"><span class="string">                         </span>|</span><br><span class="line">                         |<span class="string">  input stream</span></span><br><span class="line"><span class="string">                         V</span></span><br><span class="line"><span class="string">                         ----&gt; git-fast-import</span></span><br><span class="line"><span class="string">                                            </span>|</span><br><span class="line">                                            |<span class="string"></span></span><br><span class="line"><span class="string">                                            V</span></span><br><span class="line"><span class="string">                                         new repo</span></span><br></pre></td></tr></table></figure>
<p>要解析的元数据中存在不同的数据类型， 它们的格式为：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>blob</strong></p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">blob</span></span><br><span class="line"><span class="string">mark</span> [<span class="string">mark</span> <span class="string">id</span>]</span><br><span class="line"><span class="string">data</span> [<span class="string">file</span> <span class="string">size</span>]</span><br><span class="line">[<span class="string">file</span> <span class="string">content</span>]</span><br><span class="line"><span class="comment"># LF换行</span></span><br></pre></td></tr></table></figure>
<p>其中，mark id 的格式为 <code>:n</code>, 比如：<code>:2</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>reset</strong></p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">reset</span> [<span class="string">ref</span> <span class="string">name</span>]</span><br><span class="line"><span class="string">from</span> [<span class="string">parent</span> <span class="string">id</span>] <span class="string">(optional)</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>commit</strong></p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">commit</span> [<span class="string">ref</span> <span class="string">name</span>]</span><br><span class="line"><span class="string">mark</span> [<span class="string">mark</span> <span class="string">id</span>]</span><br><span class="line"><span class="string">author</span> [<span class="string">author</span> <span class="string">info</span>]</span><br><span class="line"><span class="string">committer</span> [<span class="string">committer</span> <span class="string">info</span>]</span><br><span class="line"><span class="string">data</span> [<span class="string">commit</span> <span class="string">message</span> <span class="string">info</span> <span class="string">size</span>]</span><br><span class="line">[<span class="string">commit</span> <span class="string">message</span> <span class="string">info</span>]</span><br><span class="line"><span class="string">merge</span> [<span class="string">merge</span> <span class="string">parent</span>]</span><br><span class="line"><span class="string">from</span> [<span class="string">from</span> <span class="string">parent</span>]</span><br><span class="line"><span class="string">filechanges</span></span><br><span class="line"><span class="comment"># LF</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>filechanges</code> 格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">type</span>] [<span class="string">file-mode</span>] [<span class="string">file-id</span>] [<span class="string">file-path</span>]</span><br><span class="line"><span class="comment"># type:</span></span><br><span class="line"><span class="comment"># M: modify</span></span><br><span class="line"><span class="comment"># A: add</span></span><br><span class="line"><span class="comment"># C: copy</span></span><br><span class="line"><span class="comment"># D: delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># file mode:</span></span><br><span class="line"><span class="comment"># 100644 or 644: normal, but non executable file</span></span><br><span class="line"><span class="comment"># 100755 or 755: normal, but executable file</span></span><br><span class="line"><span class="comment"># 120000: symlink</span></span><br><span class="line"><span class="comment"># 160000: gitlink</span></span><br><span class="line"><span class="comment"># 040000: *subdirectory</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>tag</strong></p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">tag</span> [<span class="string">tag</span> <span class="string">name</span>]</span><br><span class="line"><span class="string">mark</span> [<span class="string">mark</span> <span class="string">id</span>]</span><br><span class="line"><span class="string">from</span> [<span class="string">parent</span> <span class="string">id</span>]</span><br><span class="line"><span class="string">original-oid</span> [<span class="string">original</span> <span class="string">object</span> <span class="string">id</span>]</span><br><span class="line"><span class="string">tagger</span> [<span class="string">tagger</span> <span class="string">info</span>]</span><br><span class="line"><span class="string">data</span> [<span class="string">tag</span> <span class="string">message</span> <span class="string">info</span> <span class="string">size</span>]</span><br><span class="line">[<span class="string">tag</span> <span class="string">message</span>]</span><br><span class="line"><span class="comment"># LF</span></span><br></pre></td></tr></table></figure>
<p><code>git-fast-export</code> 的输出中，mark 标号(<code>mark ID</code>)比较关键，它是每种数据的原始顺序，以及引用时的索引号。</p>
<p>每当从 <code>git-fast-export</code> 输出流中解析到一种完整的数据，需要对数据中我们关心的字段进行检查。</p>
<p>比如，我们要根据文件大小来过滤掉仓库中的大文件，在解析到 <code>blob</code> 数据类型时，当获取到 <code>blob size</code> 信息时，可以与我们的预期大小进行对比，如果超过预期大小，则可以把这个 <code>blob</code> 标记为可删除状态，整条 <code>blob</code> 数据都不会输入到 <code>git-fast-import</code> 中，这样就做到了文件删除， 同时记住这个 <code>blob</code> 的 <code>mark ID</code>, 后续继续流式输出时，只要涉及到引用该 <code>mark ID</code> 的 <code>commit</code>，需要将其中的 <code>filechanges</code> 进行修改。如果一个 <code>commit</code> 的 <code>filechanges</code> 删减到为零，则整条 <code>commit</code> 需要丢掉，这样就实现了与删除文件相关的 <code>commit</code>的更新。</p>
<p>我们用一组示意图进行说明：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_repo_clean_graph_1.png" alt=""></p>
<p>上图表示一个简单仓库中元数据的组织方式，为了方便展示，省略了tag、引用等数据结构，只突出文件及其提交。</p>
<p>图中有4个文件：<code>Blob-A</code>, <code>Blob-B</code>, <code>Blob-C</code>, <code>Blob-D</code>。</p>
<p>产生了3个提交：<code>Commit-A</code>, <code>Commit-B</code>,<code> Commit-C</code>。</p>
<p><code>Commit-A</code>提交涉及文件<code>Blob-A</code>, <code>Blob-B</code>, <code>Commit-B</code>提交涉及文件<code>Blob-C</code>, <code>Commit-C</code>提交涉及文件<code>Blob-D</code>。</p>
<p>使用<code>git-fast-export</code>导出仓库的元数据时，是按数据的先后顺序流式输出的，这个顺序即是<code>mark ID</code>的顺序。所以，本示例图中的数据顺序就是：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_repo_clean_graph_2.png" alt=""></p>
<p>现在的目标是要删除文件<code>Blob-C</code>，以及它涉及到的提交。</p>
<p>删除的方式可以从文件的几个维度入手：</p>
<ol>
<li class="lvl-3">
<p>文件的名称</p>
</li>
<li class="lvl-3">
<p>文件的ID, 即图中的 <code>original-oid</code></p>
</li>
<li class="lvl-3">
<p>文件的大小，即图中的 <code>data size</code></p>
</li>
</ol>
<p>无论哪种方式，目的是要先筛选出目标文件，然后进行标记。</p>
<p>所谓标记，可以简单的认为是将它的<code>mark ID</code>从原有的序号系统中剔除，即标记为0。</p>
<p>当<code>blob</code>的<code>mark ID</code>标记为0之后，后续解析到的<code>commit</code>时，会检查其中的<code>filechanges</code>，标记为0的<code>filechange</code>会被移除，如果最终的<code>filechanges</code>数量为0，说明该条<code>commit</code>所涉及到的所以修改文件都已经被删除，则整条<code>commit</code>也应该被删除。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_repo_clean_graph_3.png" alt=""></p>
<p>在<code>Blob-C</code>, <code>Commit-B</code>标记为删除之后，后续所有数据的<code>mark ID</code>需要相应的改变, 以便保持一致。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/git_repo_clean_graph_4.png" alt=""></p>
<p>如<code>Commit-C</code> 的<code>mark ID</code>变为5， <code>parent commit(from)</code>指向3，<code>filechanges</code>指向4。</p>
<p>这样就完成了删除文件<code>Blob-C</code>，以及其涉及到的<code>Commit-C</code>。</p>
<p>对于多文件，或者多分支删除，因为整个过程的数据是流式输出，所有的数据都按<code>出场顺序</code>有自己的唯一编号，所以处理起来是一样的。</p>
<p>以上就是 <code>git-repo-clean</code>的内部原理。</p>
<h5 id="使用建议：">使用建议：</h5>
<p>不管是哪种重写历史的工具，都是对仓库进行破坏性操作，有些事项需要特别注意。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>事项 1：备份你的原始仓库</p>
</li>
</ul>
<blockquote>
<p><code>git repo-clean</code> 在交互模式下，会询问用户是否进行备份，如果选择是，则会自动帮用户进行仓库备份。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>事项 2：重写历史会改变 commit 的 ID 值，可能会影响现存 PR，所以建议先关掉或者合并现存 PR。</p>
</li>
<li class="lvl-2">
<p>事项 3：在本地仓库重写历史并强制推送到远程仓库之后，应该告知所有使用该仓库进行协同开发的人，需要同步远程仓库，避免再将本地旧的历史提交到远程。</p>
</li>
</ul>
<blockquote>
<p>参考远程仓库更改后如何更新本地仓库[<a href="https://gitee.com/oschina/git-repo-clean/blob/main/docs/repo-update.md">11]</a>[<a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/newren/git-filter-repo/docs/html/git-rebase.html">12]</a></p>
</blockquote>
<h5 id="后续：">后续：</h5>
<p>在<code>v1.3.0</code>中我们已经实现将大文件转换为 <code>Git LFS</code> 文件的功能。</p>
<h5 id="引用参考">引用参考</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>[1]. <a href="https://gitee.com/cactusinhand/all-about-git/blob/master/doc/large-git-repos-zh.md">https://gitee.com/cactusinhand/all-about-git/blob/master/doc/large-git-repos-zh.md</a></p>
</li>
<li class="lvl-2">
<p>[2]. <a href="https://git-scm.com/docs/gitignore">https://git-scm.com/docs/gitignore</a></p>
</li>
<li class="lvl-2">
<p>[3]. <a href="https://gitee.com/help/articles/4235">https://gitee.com/help/articles/4235</a></p>
</li>
<li class="lvl-2">
<p>[4]. <a href="https://git-scm.com/docs/git-filter-branch">https://git-scm.com/docs/git-filter-branch</a></p>
</li>
<li class="lvl-2">
<p>[5]. <a href="https://git-scm.com/docs/git-filter-branch#PERFORMANCE">https://git-scm.com/docs/git-filter-branch#PERFORMANCE</a></p>
</li>
<li class="lvl-2">
<p>[6]. <a href="https://git-scm.com/docs/git-filter-branch#SAFETY">https://git-scm.com/docs/git-filter-branch#SAFETY</a></p>
</li>
<li class="lvl-2">
<p>[7]. <a href="https://github.com/newren/git-filter-repo">https://github.com/newren/git-filter-repo</a></p>
</li>
<li class="lvl-2">
<p>[8]. <a href="https://github.com/rtyley/bfg-repo-cleaner">https://github.com/rtyley/bfg-repo-cleaner</a></p>
</li>
<li class="lvl-2">
<p>[9]. <a href="https://github.com/github/git-sizer">https://github.com/github/git-sizer</a></p>
</li>
<li class="lvl-2">
<p>[10]. <a href="https://gitee.com/oschina/git-repo-clean">开源中国/git-repo-clean</a></p>
</li>
<li class="lvl-2">
<p>[11]. <a href="https://gitee.com/oschina/git-repo-clean/blob/main/docs/repo-update.md">https://gitee.com/oschina/git-repo-clean/blob/main/docs/repo-update.md</a></p>
</li>
<li class="lvl-2">
<p>[12]. <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/newren/git-filter-repo/docs/html/git-rebase.html">https://htmlpreview.github.io/?https://raw.githubusercontent.com/newren/git-filter-repo/docs/html/git-rebase.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>如何向 Git 社区提交代码(2)</title>
    <url>/posts/23bf24d1.html</url>
    <content><![CDATA[<h3 id="背景">背景</h3>
<p>第一次向 Git 社区提交代码起源于 Gitee 的一个需求。Gitee 创建新仓库有多种方式，其中一种是根据用户提供的仓库 URL 导入新仓库，Gitee 首先会对用户提供的 URL 进行校验，只有合格的仓库地址才会生成新仓库。但是有种情况比较特别，若用户确实提供了一个合法的 Git 仓库地址，但是这个仓库不是完整的，常见的情况就是浅仓库(shallow repo)，这类仓库缺乏足够的历史提交信息，因此会带来一些问题。为了避免这种情况，在服务端就需要对用户导入的仓库进行特别处理。在服务端，导入仓库的动作本质上就是执行 <code>git clone --mirror</code> 命令，那么有没有可能在执行这个克隆命令的过程中就对仓库进行判断呢？如果能，这将避免克隆完整个仓库再进行判断仓库是否为浅仓库，这样无疑更有效。于是我开始研究 Git 源码，琢磨如何给 <code>git-clone</code> 命令赋予一项新的能力。</p>
<p>按照前面的方法向 Git 社区提交了第一版代码：<a href="https://public-inbox.org/git/pull.865.git.1612409491842.gitgitgadget@gmail.com/#t">v1</a></p>
<p>很快收到 <strong><a href="https://public-inbox.org/git/xmqq35yc9yan.fsf@gitster.c.googlers.com/#t">Junio C Hamano</a></strong> 反馈，主要问题有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>commit 信息中说明不清，英文语法错误：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; This patch add a new option that reject to clone a shallow repository.</span><br><span class="line"></span><br><span class="line">A canonical form of our log message starts by explaining the need,</span><br><span class="line">and then presents the solution at the end.</span><br><span class="line">一条规范的 commit 信息格式应该是在开始就解释更改需求，然后在结尾提供解决方案。</span><br><span class="line"></span><br><span class="line">&gt; Clients don&#x27;t know it&#x27;s a shallow repository until they download it</span><br><span class="line">&gt; locally, in some scenariors, clients just don&#x27;t want to clone this kind</span><br><span class="line"></span><br><span class="line">&quot;scenarios&quot;.  &quot;in some scenarios&quot; would have to be clarified a bit</span><br><span class="line">more to justify why it is a good idea to have such a feature.</span><br><span class="line">这里的需求场景描述地不够有说服力。</span><br><span class="line"></span><br><span class="line">&gt; of repository, and want to exit the process immediately without creating</span><br><span class="line">&gt; any unnecessary files.</span><br><span class="line"></span><br><span class="line">&quot;clients don&#x27;t know it&#x27;s a shallow repository until they download&quot;</span><br><span class="line">leading to &quot;so let&#x27;s reject immediately upon finding out that they</span><br><span class="line">are shallow&quot; does make sense as a flow of thought, though.</span><br><span class="line">这里表述不够清晰，Junio 顺便提供了他的建议</span><br><span class="line">&gt; +--no-shallow::</span><br><span class="line">&gt; +	Don&#x27;t clone a shallow source repository. In some scenariors, clients</span><br><span class="line"></span><br><span class="line">&quot;scenarios&quot; (no &#x27;r&#x27;).</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>新增选项 <code>--no-shallow</code> 不对，应该考虑到布尔类选项存在反选情况，即 <code>--no-no-shallow</code> ，因此不应该这么写，建议改为 <code>--reject-shallow</code>， 它的反选即为 <code>--no-reject-shallow</code>，这样语义上也更符合直觉：</p>
</li>
</ul>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&gt; diff --git a/builtin/clone.c b/builtin/clone.c</span><br><span class="line"></span><br><span class="line">&gt; @@ -90,6 +91,7 @@ static struct option builtin_clone_options[] = &#123;</span><br><span class="line">&gt;  	OPT__VERBOSITY(&amp;option_verbosity),</span><br><span class="line">&gt;  	OPT_BOOL(0, &quot;progress&quot;, &amp;option_progress,</span><br><span class="line">&gt;  		 N_(&quot;force progress reporting&quot;)),</span><br><span class="line">&gt; +	OPT_BOOL(0, &quot;no-shallow&quot;, &amp;option_no_shallow, N_(&quot;don&#x27;t clone shallow repository&quot;)),</span><br><span class="line">&gt;  	OPT_BOOL(&#x27;n&#x27;, &quot;no-checkout&quot;, &amp;option_no_checkout,</span><br><span class="line">&gt;  		 N_(&quot;don&#x27;t create a checkout&quot;)),</span><br><span class="line">&gt;  	OPT_BOOL(0, &quot;bare&quot;, &amp;option_bare, N_(&quot;create a bare repository&quot;)),</span><br><span class="line"></span><br><span class="line">It is a bad idea to give a name that begins with &quot;no-&quot; to an option</span><br><span class="line">whose default can be tweaked by a configuration variable [*].  If</span><br><span class="line">the configuration is named &quot;rejectshallow&quot;, perhaps it is better to</span><br><span class="line">call it &quot;--reject-shallow&quot; instead.</span><br><span class="line"></span><br><span class="line">This is because configured default must be overridable from the</span><br><span class="line">command line.  I.e. even if you have in your ~/.gitconfig this:</span><br><span class="line"></span><br><span class="line">    [clone]</span><br><span class="line">        rejectshallow = true</span><br><span class="line"></span><br><span class="line">you should be able to say &quot;allow it only this time&quot;, with</span><br><span class="line"></span><br><span class="line">    $ git clone --no-reject-shallow http://github.com/git/git/ git</span><br><span class="line"></span><br><span class="line">and you do not want to have to say &quot;--no-no-shallow&quot;, which sounds</span><br><span class="line">just silly.</span><br><span class="line"></span><br><span class="line">	Side note. it is a bad idea in general, even if the option</span><br><span class="line">	does not have corresponding configuration variable.  The</span><br><span class="line">	existing &quot;no-checkout&quot; is a historical accident that</span><br><span class="line">	happened long time ago and cannot be removed due to</span><br><span class="line">	compatibility.  Let&#x27;s not introduce a new option that</span><br><span class="line">	follows such a bad pattern.</span><br><span class="line"></span><br><span class="line">	Junio 进一步解释：现存的选项 `no-checkout` 是一个很久之前的历史错误，</span><br><span class="line">	由于兼容性，已经无法移除这个错误了，现在新的选项不应该按照这种模式命名。</span><br><span class="line">	P.S. 刚好我就是按照`no-checkout`选项的模式创造出`no-shllow`选项的-:)</span><br></pre></td></tr></table></figure>
<p>更重要的是，<strong>命令行优先于配置</strong>，即命令行选项要能够覆盖配置文件选项。当配置文件从全局上不允许克隆 shllow 仓库时，而用户想要允许单次克隆 shallow 仓库时，自然地，他会使用 <code>--no-shallow</code> 选项的反选项 <code>--no-no-shallow</code> 来覆盖掉配置中的选项 。但这样 <code>--no-no-shallow</code> 听来去就很傻。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于 Git 存在多种传输协议，目前的修改只是解决了本地克隆问题，因此仍需改进：</p>
</li>
</ul>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&gt; @@ -963,6 +968,7 @@ static int path_exists(const char *path)</span><br><span class="line">&gt;  int cmd_clone(int argc, const char **argv, const char *prefix)</span><br><span class="line">&gt;  &#123;</span><br><span class="line">&gt;  	int is_bundle = 0, is_local;</span><br><span class="line">&gt; +	int is_shallow = 0;</span><br><span class="line">&gt;  	const char *repo_name, *repo, *work_tree, *git_dir;</span><br><span class="line">&gt;  	char *path, *dir, *display_repo = NULL;</span><br><span class="line">&gt;  	int dest_exists, real_dest_exists = 0;</span><br><span class="line">&gt; @@ -1215,6 +1221,7 @@ int cmd_clone(int argc, const char **argv, const char *prefix)</span><br><span class="line">&gt;  		if (filter_options.choice)</span><br><span class="line">&gt;  			warning(_(&quot;--filter is ignored in local clones; use file:// instead.&quot;));</span><br><span class="line">&gt;  		if (!access(mkpath(&quot;%s/shallow&quot;, path), F_OK)) &#123;</span><br><span class="line">&gt; +			is_shallow = 1;</span><br><span class="line">&gt;  			if (option_local &gt; 0)</span><br><span class="line">&gt;  				warning(_(&quot;source repository is shallow, ignoring --local&quot;));</span><br><span class="line">&gt;  			is_local = 0;</span><br><span class="line"></span><br><span class="line">This change is to the local clone codepath.  Cloning over the wire</span><br><span class="line">would not go through this part.  And throughout the patch, this is</span><br><span class="line">the only place that sets is_shallow to 1.</span><br><span class="line"></span><br><span class="line">Also let&#x27;s note that this is after we called parse_options(), so the</span><br><span class="line">value of option_no_shallow is known at this point.</span><br><span class="line"></span><br><span class="line">So, this patch does not even *need* to introduce a new &quot;is_shallow&quot;</span><br><span class="line">variable at all.  It only needs to add</span><br><span class="line"></span><br><span class="line">                        if (option_no_shallow)</span><br><span class="line">                                die(...);</span><br><span class="line"></span><br><span class="line">instead of adding &quot;is_shallow = 1&quot; to the above hunk.</span><br><span class="line"></span><br><span class="line">I somehow think that this is only half a feature---wouldn&#x27;t it be</span><br><span class="line">more useful if we also rejected a non-local clone from a shallow</span><br><span class="line">repository?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>测试代码中的问题：</p>
</li>
</ul>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">And for that ...</span><br><span class="line"></span><br><span class="line">&gt; diff --git a/t/t5606-clone-options.sh b/t/t5606-clone-options.sh</span><br><span class="line">&gt; index 7f082fb23b6a..9d310dbb158a 100755</span><br><span class="line">&gt; --- a/t/t5606-clone-options.sh</span><br><span class="line">&gt; +++ b/t/t5606-clone-options.sh</span><br><span class="line">&gt; @@ -42,6 +42,13 @@ test_expect_success &#x27;disallows --bare with --separate-git-dir&#x27; &#x27;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;  &#x27;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; +test_expect_success &#x27;reject clone shallow repository&#x27; &#x27;</span><br><span class="line">&gt; +	git clone --depth=1 --no-local parent shallow-repo &amp;&amp;</span><br><span class="line">&gt; +	test_must_fail git clone --no-shallow shallow-repo out 2&gt;err &amp;&amp;</span><br><span class="line">&gt; +	test_i18ngrep -e &quot;source repository is shallow, reject to clone.&quot; err</span><br><span class="line">&gt; +</span><br><span class="line">&gt; +&#x27;</span><br><span class="line">&gt; +</span><br><span class="line"></span><br><span class="line">... in addition to the test for a local clone above, you&#x27;d also want</span><br><span class="line">to test a non-local clone, perhaps like so:</span><br><span class="line"></span><br><span class="line">test_expect_success &#x27;reject clone shallow repository&#x27; &#x27;</span><br><span class="line">	rm -fr shallow-repo &amp;&amp;</span><br><span class="line">	git clone --depth=1 --no-local parent shallow-repo &amp;&amp;</span><br><span class="line">	test_must_fail git clone --no-shallow --no-local shallow-repo out 2&gt;err &amp;&amp;</span><br><span class="line">	test_i18ngrep -e &quot;source repository is shallow, reject to clone.&quot; err</span><br><span class="line"></span><br><span class="line">&#x27;</span><br><span class="line"></span><br><span class="line">Ditto for the other test script.</span><br><span class="line"></span><br><span class="line">Also, you would want to make sure that the command line overrides</span><br><span class="line">the configured default.  I.e.</span><br><span class="line"></span><br><span class="line">	git -c clone.rejectshallow=false clone --reject-shallow</span><br><span class="line"></span><br><span class="line">should refuse to clone from a shallow one, while there should be a</span><br><span class="line">way to countermand a configured &quot;I always refuse to clone from a</span><br><span class="line">shallow repository&quot; with &quot;but let&#x27;s allow it only this time&quot;, i.e.</span><br><span class="line"></span><br><span class="line">	git -c clone.rejectshallow=true clone --no-reject-shallow</span><br><span class="line"></span><br><span class="line">or something along the line.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; diff --git a/t/t5611-clone-config.sh b/t/t5611-clone-config.sh</span><br><span class="line">&gt; index 8e0fd398236b..3aab86ad4def 100755</span><br><span class="line">&gt; --- a/t/t5611-clone-config.sh</span><br><span class="line">&gt; +++ b/t/t5611-clone-config.sh</span><br><span class="line">&gt; @@ -92,6 +92,13 @@ test_expect_success &#x27;clone -c remote.&lt;remote&gt;.fetch=&lt;refspec&gt; --origin=&lt;name&gt;&#x27; &#x27;</span><br><span class="line">&gt;  	test_cmp expect actual</span><br><span class="line">&gt;  &#x27;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; +test_expect_success &#x27;clone -c clone.rejectshallow&#x27; &#x27;</span><br><span class="line">&gt; +	rm -rf child &amp;&amp;</span><br><span class="line">&gt; +	git clone --depth=1 --no-local . child &amp;&amp;</span><br><span class="line">&gt; +	test_must_fail git clone -c clone.rejectshallow child out 2&gt;err &amp;&amp;</span><br><span class="line"></span><br><span class="line">This is not quite right, even though it may happen to work.  The</span><br><span class="line">&quot;clone.rejectshallow&quot; variable is a configuration about what should</span><br><span class="line">happen when creating a new repository by cloning, so letting &quot;git</span><br><span class="line">clone -c var[=val]&quot; to set the variable _in_ the resulting repository</span><br><span class="line">would not make much sense.  Even if the clone succeeded, nobody would</span><br><span class="line">look at that particular configuration variable that is set in the</span><br><span class="line">resulting repository.</span><br><span class="line"></span><br><span class="line">I think it would communicate to the readers better what we are</span><br><span class="line">trying to do, if we write</span><br><span class="line"></span><br><span class="line">	test_must_fail git -c clone.rejectshallow=true clone child out</span><br><span class="line"></span><br><span class="line">instead.</span><br><span class="line"></span><br><span class="line">Thanks.</span><br></pre></td></tr></table></figure>
<p>通过测试代码 Junio 指出： <code>clone.rejectshallow</code> 配置和命令行选项 <code>--reject-shallow</code> 存在逻辑上的交叉重叠问题，因此测试时应该体现出这一点。</p>
<p>以上就是我第一次提交的代码，没想到能很快收到那么多宝贵的检视建议。但是，这只是开始，后面还有更多的检视回合，收到了更加细致的检视意见。</p>
<p>比如 <a href="https://public-inbox.org/git/nycvar.QRO.7.76.6.2103311146210.52@tvgsbejvaqbjf.bet/">Johannes Schindelin</a> 给了一些意见：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">我觉得这个补丁大部分都很好，但我还有一点点改进建议</span><br><span class="line">I like most of the patch, and will only point out a couple of things that</span><br><span class="line">I think can be improved even further.</span><br><span class="line"></span><br><span class="line">&gt; diff --git a/Documentation/git-clone.txt b/Documentation/git-clone.txt</span><br><span class="line">&gt; index 02d9c19cec75..0adc98fa7eee 100644</span><br><span class="line">&gt; --- a/Documentation/git-clone.txt</span><br><span class="line">&gt; +++ b/Documentation/git-clone.txt</span><br><span class="line">&gt; @@ -149,6 +149,11 @@ objects from the source repository into a pack in t=</span><br><span class="line">he cloned repository.</span><br><span class="line">&gt;  --no-checkout::</span><br><span class="line">&gt;  	No checkout of HEAD is performed after the clone is complete.</span><br><span class="line">&gt;</span><br><span class="line">&gt; +--[no-]reject-shallow::</span><br><span class="line">&gt; +	Fail if the source repository is a shallow repository.</span><br><span class="line">&gt; +	The &#x27;clone.rejectShallow&#x27; configuration variable can be used to</span><br><span class="line">&gt; +	give the default.</span><br><span class="line"></span><br><span class="line">使用 `to specify the default` 说起来更顺口一些</span><br><span class="line">I am not a native speaker, either, but I believe that it would &quot;roll off</span><br><span class="line">the tongue&quot; a bit better to say &quot;to specify the default&quot;.</span><br></pre></td></tr></table></figure>
<p>变量命名问题：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&gt; diff --git a/builtin/clone.c b/builtin/clone.c</span><br><span class="line">&gt; index 51e844a2de0a..eeddd68a51f4 100644</span><br><span class="line">&gt; --- a/builtin/clone.c</span><br><span class="line">&gt; +++ b/builtin/clone.c</span><br><span class="line">&gt; @@ -50,6 +50,8 @@ static int option_no_checkout, option_bare, option_mir=</span><br><span class="line">ror, option_single_branch</span><br><span class="line">&gt;  static int option_local =3D -1, option_no_hardlinks, option_shared;</span><br><span class="line">&gt;  static int option_no_tags;</span><br><span class="line">&gt;  static int option_shallow_submodules;</span><br><span class="line">&gt; +static int option_shallow = -1;    /* unspecified */</span><br><span class="line">&gt; +static int config_shallow = -1;    /* unspecified */</span><br><span class="line"></span><br><span class="line">I would much prefer those variable names to include an indicator that this</span><br><span class="line">is about _rejecting_ shallow clones. I.e. `option_reject_shallow`.</span><br><span class="line"></span><br><span class="line">Also, I think that we can do with just a single `option_reject_shallow`</span><br><span class="line">(we do not even need that `reject_shallow` variable in `cmd_clone()`):</span><br><span class="line"></span><br><span class="line"><span class="deletion">- in `git_clone_config()`, only override it if it is still unspecified:</span></span><br><span class="line"></span><br><span class="line">	if (!strcmp(k, &quot;clone.rejectshallow&quot;) &amp;&amp; option_reject_shallow &lt; 0)</span><br><span class="line">		option_reject_shallow =3D git_config_bool(k,v);</span><br><span class="line"></span><br><span class="line"><span class="deletion">- in `cmd_clone()`, test for a _positive_ value:</span></span><br><span class="line"></span><br><span class="line">	if (option_reject_shallow &gt; 0)</span><br><span class="line">		die(_(&quot;source repository is shallow, reject to clone.&quot;));</span><br><span class="line"></span><br><span class="line">  and</span><br><span class="line"></span><br><span class="line">	if (option_reject_shallow &gt; 0)</span><br><span class="line"> 		transport_set_option(transport, TRANS_OPT_REJECT_SHALLOW, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">One thing to note (in the commit message, would be my preference) is that</span><br><span class="line">`cmd_clone()` is _particular_ in that it runs `git_config()` _twice_. Once</span><br><span class="line">before the command-line options are parsed, and once after the new Git</span><br><span class="line">repository has been initialized. Note that my suggestion still works with</span><br><span class="line">that: if either the original config, or the new config set</span><br><span class="line">`clone.rejectShallow`, it is picked up correctly, with the latter</span><br><span class="line">overriding the former if both configs want to set it.</span><br></pre></td></tr></table></figure>
<p>使用 <code>option_reject_shallow</code> 比 <code>config_shallow</code> 更好一些，它能更直接地表明这个选项是要拒绝 <em>shallow clone</em> 的。<s>同时他提醒，在 <code>cmd_clone()</code>函数中 <code>git_config</code> 会被调用两次，使用 <code>option_reject_shallow</code> 能避免在 <code>cmd_clone</code> 中使用 <code>reject_shallow</code></s> 。</p>
<p>P.S. 划线这段话是错误的，见 Johannes 本人回复：<a href="https://public-inbox.org/git/nycvar.QRO.7.76.6.2104010021510.54@tvgsbejvaqbjf.bet/">Johannes’reply</a>，以及 Junio 的回复：<a href="https://public-inbox.org/git/xmqqim5754rl.fsf@gitster.g/">Junio’s reply</a>。最后用了两个变量: <code>option_reject_shallow</code>，<code>config_reject_shallow</code>，在 <code>cmd_clone()</code> 中它们共同决定另一个变量：<code>reject_shallow</code>。</p>
<p>后面同样变量命名：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&gt; diff --git a/fetch-pack.c b/fetch-pack.c</span><br><span class="line">&gt; index fb04a76ca263..34d0c2896e2e 100644</span><br><span class="line">&gt; --- a/fetch-pack.c</span><br><span class="line">&gt; +++ b/fetch-pack.c</span><br><span class="line">&gt; @@ -1129,9 +1129,11 @@ static struct ref *do_fetch_pack(struct fetch_pac=</span><br><span class="line">k_args *args,</span><br><span class="line">&gt;  	if (args-&gt;deepen)</span><br><span class="line">&gt;  		setup_alternate_shallow(&amp;shallow_lock, &amp;alternate_shallow_file,</span><br><span class="line">&gt;  					NULL);</span><br><span class="line">&gt; -	else if (si-&gt;nr_ours || si-&gt;nr_theirs)</span><br><span class="line">&gt; +	else if (si-&gt;nr_ours || si-&gt;nr_theirs) &#123;</span><br><span class="line">&gt; +		if (args-&gt;remote_shallow)</span><br><span class="line"></span><br><span class="line">Even as a non-casual reader, this name `remote_shallow` leads me to assume</span><br><span class="line">incorrect things. This option is not about wanting a remote shallow</span><br><span class="line">repository, it is about rejecting a remote shallow repository.</span><br><span class="line">用 `reject_shallow` 代替 `remote_shllow`</span><br><span class="line">Please name this attribute `reject_shallow` instead of `remote_shallow`.</span><br><span class="line">That will prevent future puzzlement.</span><br></pre></td></tr></table></figure>
<p>Johannes 还对测试用例提出了一些检视意见，篇幅有限，这里省略。</p>
<p>在最后几个回合，Junio 又给出了很多有意义的检视意见：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&gt; In some scenarios, users may want more history than the repository</span><br><span class="line">&gt; offered for cloning, which happens to be a shallow repository, can</span><br><span class="line">&gt; give them. But because users don&#x27;t know it is a shallow repository</span><br><span class="line">&gt; until they download it to local, users should have the option to</span><br><span class="line"></span><br><span class="line">&#x27;should&#x27; 在这里感觉语气太重了</span><br><span class="line">I find the &quot;should&quot; too strong, but let&#x27;s keep reading.</span><br><span class="line"></span><br><span class="line">&gt; refuse to clone this kind of repository, and may want to exit the</span><br><span class="line">&gt; process immediately without creating any unnecessary files.</span><br><span class="line">确认是语气重了。同时存在冗余。</span><br><span class="line">Yes, that is too strong and also redundant.</span><br><span class="line"></span><br><span class="line">&gt; Althought there is an option &#x27;--depth=x&#x27; for users to decide how</span><br><span class="line">&gt; deep history they can fetch, but as the unshallow cloning&#x27;s depth</span><br><span class="line">句子若以 &#x27;although&#x27; 开头，则后面不应该用 `but`做转折。</span><br><span class="line">&quot;Although&quot;; if you begin with &quot;although&quot;, you shouldn&#x27;t write &quot;but&quot;.</span><br><span class="line"></span><br><span class="line">&gt; is INFINITY, we can&#x27;t know exactly the minimun &#x27;x&#x27; value that can</span><br><span class="line">&gt; satisfy the minimum integrity,</span><br><span class="line">&gt; so we can&#x27;t pass &#x27;x&#x27; value to --depth,</span><br><span class="line">&gt; and expect this can obtain a complete history of a repository.</span><br><span class="line"></span><br><span class="line">If the argument were &quot;we might start with depth x, and the source</span><br><span class="line">may be deep enough to give us x right now, but we may want to deepen</span><br><span class="line">more than they can offer, and such a user would want to be able to</span><br><span class="line">say &#x27;I want depth=x now, but make sure they are not shallow&#x27;&quot;, I</span><br><span class="line">would understand it, but I do not see where the &quot;minimum integrity&quot;</span><br><span class="line">comes from---there doesn&#x27;t appear to be anything related to</span><br><span class="line">integrity here.</span><br><span class="line"></span><br><span class="line">&gt; In other scenarios, if we have an API that allow us to import external</span><br><span class="line"></span><br><span class="line">&quot;allows&quot;</span><br><span class="line"></span><br><span class="line">&gt; repository, and then perform various operations on the repo.</span><br><span class="line">&gt; But if the imported is a shallow one(which is actually possible), it</span><br><span class="line">&gt; will affect the subsequent operations. So we can choose to refuse to</span><br><span class="line">&gt; clone, and let&#x27;s just import a normal repository.</span><br><span class="line">建议丢掉这一整段，因为它跟前面讲的场景差不多，并没有提供新信息。</span><br><span class="line">I&#x27;d suggest dropping this entire paragraph.  That is not any new</span><br><span class="line">scenario at all.  API or not, you essentially just said &quot;you can do</span><br><span class="line">various things on your clone once you have it, but some things you</span><br><span class="line">may want to do you would want a full history&quot;.  That is what you</span><br><span class="line">started the whole discussion above and does not add any new</span><br><span class="line">information.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; @@ -858,6 +861,9 @@ static int git_clone_config(const char *k, const char *v, void *cb)</span><br><span class="line">&gt;  		free(remote_name);</span><br><span class="line">&gt;  		remote_name = xstrdup(v);</span><br><span class="line">&gt;  	&#125;</span><br><span class="line">&gt; +	if (!strcmp(k, &quot;clone.rejectshallow&quot;) &amp;&amp; option_reject_shallow &lt; 0)</span><br><span class="line">&gt; +		option_reject_shallow = git_config_bool(k, v);</span><br><span class="line"></span><br><span class="line">Does this &quot;single variable is enough&quot; really work?</span><br><span class="line"></span><br><span class="line">Imagine that the first time around we&#x27;d read from $HOME/.gitconfig</span><br><span class="line">that says true (flips the variable from &quot;unspecified&quot;).  Further</span><br><span class="line">imagine that we are running &quot;git clone -c config.rejectShallow=no&quot;</span><br><span class="line">to countermand the global config.  We call write_config() to write</span><br><span class="line">the extra configuration value out, and then call git_config() to</span><br><span class="line">read from the repository configuration again.</span><br><span class="line"></span><br><span class="line">Because of the value taken from $HOME/.gitconfig, however, the</span><br><span class="line">attempt to override is silently ignored, isn&#x27;t it?</span><br><span class="line"></span><br><span class="line">Other than that, the changes to the code from the previous round</span><br><span class="line">looked sensible.</span><br><span class="line"></span><br><span class="line">虽然比上一版的更新好了很多，但Junio并没有放弃任何可能的问题，仍对config配置</span><br><span class="line">和option配置有疑问，他的顾虑是正确的，这为下一版的更新提供了正确的思路。</span><br></pre></td></tr></table></figure>
<p>这就是我第一次向 Git 社区提交代码的情况：问题多多，反馈多多。各种严谨细致又有启发性的检视意见让我感受到了 Git 社区的技术氛围。这个过程中让我不断思考如何让代码写得更好：更有逻辑，更简洁，更严谨，而不仅仅是实现功能。</p>
<p>这个经验让我想到，在英语中有个两个单词可以很贴切的形容他们对待代码的态度：<code>polish</code>，<code>cooking</code>。<br>
<code>polish</code> 动词意为润色，修改，抛光，打磨。用在代码上， commit 信息上，甚至写文档上，意味着这些过程是不断改进，不断变得更好。<br>
<code>cooking</code> 意为烹饪，比喻写代码就像烹饪，所谓心急吃不了热豆腐，即使做简单的菜都需要耐心，细心。</p>
<p>回到主题，前面的每次修改，直接强推到原来的PR中即可， <a href="https://gitgitgadget.github.io/">GitGitGadget</a> 会自动将每次的更新转换为不同的版本再提交到上游社区。那如何确定提交的版本是最终版本呢？前面提到过 Git 的几个主要分支，当我提交到第十版后，很快就被合入到 <code>seen</code>分支，意味着被初步接受，然后又马上进入 <code>next</code> 分支，意味着各项测试也没问题，然后又马上进入 <code>master</code> 分支。特别地，这个过程会有 <strong>状态更新</strong> 提醒， Git 社区有个 <a href="https://lore.kernel.org/git/xmqqy2dw2pai.fsf@gitster.g/#r">What’s cooking in git.git</a> 栏目，是维护者 Junio 用来管理各种提交的状态更新的，它会表明目前社区正在 cooking 哪些人的哪些代码(patch)，以及各个代码的目前状态。当你的代码在 <strong>What’s cooking in git.git</strong>  中进入 <code>Graduated to 'master'</code> 或者 <code>Will merge to 'master'</code>，那就表明马上会合入主线啦。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Workflow</tag>
      </tags>
  </entry>
  <entry>
    <title>GitOps: 一种 DevOps 的最佳实践</title>
    <url>/posts/f8df64f6.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Workflow</tag>
        <tag>GitOps</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>如何向 Git 社区提交代码</title>
    <url>/posts/d699447b.html</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>作为目前最流行的开源分布式<strong>版本控制系统</strong>，Git 的诞生超过17年，但目前仍然具有非常活跃的开发者社区，远超出一般开源软件的生命周期，其代码贡献者也已经超过 1.5K，并且仍源源不断有新增贡献者，这使得 Git 能够持续不断地有各种更新、功能优化等等。</p>
<p>但是要想参与到这个大型的国际化的开源社区中来并成为源码贡献者，对于国内大部分开发者来说并不是那么容易。</p>
<p>在 Gitee 架构团队中，我有机会深入探究 <a href="https://cactusinhand.github.io/2022/02/10/git-from-inside-to-outside/">Git的底层原理</a>，以及<a href="https://cactusinhand.github.io/2022/02/12/Git-tool-git-repo-clean/"> Git 的一些应用</a>，这个过程中我也成为了 Git 社区的贡献者。截至目前，我向 Git 社区提交了 <a href="https://git.kernel.org/pub/scm/git/git.git/log/?qt=author&amp;q=lilinchao">4 次代码</a>。现在，作为贡献者中的一员，我很乐意分享这个过程，以便帮助更多人有机会参与到像 Git 这样的大型开源社区中来。</p>
<p>这个系列将从 Git 社区贡献者的角度，向广大开发者分享我如何向 Git 官方社区提交代码，以及从提交代码到最终合并代码的整个过程。</p>
<h2 id="背景">背景</h2>
<p>如果你在使用 Git 时发现了 bug，或者觉得某些命令没有你想要的功能，或者你发现它的帮助文档描述不够清晰让你感到迷惑，你完全可以自己修改 Git 源码，从而实现自己的预期功能。</p>
<h2 id="获取源码">获取源码</h2>
<p>首先从 <a href="https://github.com/git/git">Git 在 Github 镜像仓</a> 上 fork 出一个自己的仓库，然后克隆到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/myfork/git mygit</span><br><span class="line">$ <span class="built_in">cd</span> mygit</span><br><span class="line"><span class="comment"># 添加上游远程仓库，便于更新最新代码</span></span><br><span class="line">$ git remote add upstream https://github.com/git/git</span><br></pre></td></tr></table></figure>
<h2 id="编译源码">编译源码</h2>
<p>确保在未作任何修改之前，代码不缺少任何编译依赖，能够正常编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切出一个自己的主题分支</span></span><br><span class="line">$ git checkout -b myown-topic origin/master</span><br><span class="line">$ make DEVELOPER=1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>topic</code> 是个人主题分支，所谓主题就是自己要修改什么那就是什么主题。</p>
</blockquote>
<h2 id="编写代码">编写代码</h2>
<p>其实编写代码的过程就是一个模仿的过程，先观察别人是怎么写的，再模仿写即可。比如，观察别人是如何定义变量，在哪里定义，如何处理缩进，如何定义函数等等，按照同样的风格进行模仿大致是不会出错的。如果想看详细的编码规范，可参考 <a href="https://gitee.com/mirrors/git/blob/master/Documentation/CodingGuidelines">Git 代码编写规范</a></p>
<h2 id="测试代码">测试代码</h2>
<p>测试代码都在 <code>t/</code> 目录下，请阅读 <code>t/README</code> 文档，然后编写测试用例。</p>
<p>运行单项测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make DEVELOPER=1</span><br><span class="line">$ <span class="built_in">cd</span> t/ &amp;&amp; prove t9999-psuh-tutorial.sh</span><br></pre></td></tr></table></figure>
<p>或者运行全部测试，以确保自己的修改没有影响别的代码运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> t/</span><br><span class="line">$ prove -j$(<span class="built_in">nproc</span>) --shuffle t[0-9]*.sh</span><br></pre></td></tr></table></figure>
<h2 id="文档更新">文档更新</h2>
<p>如果修改是新增某个特性，或者增加某个选项配置等，都需要补充文档，使用说明，manpage等。</p>
<p>Linux环境中需要安装 <code>asciidoc</code> 工具，来支持文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install asciidoc</span><br><span class="line">$ make all doc</span><br><span class="line">$ make check-docs</span><br></pre></td></tr></table></figure>
<p>对待文档需要跟对待代码一样，因为它们同样重要。和编写代码一样，需要遵循已有文档的风格，详细风格指导文档请参考可参考 <a href="https://gitee.com/mirrors/git/blob/master/Documentation/CodingGuidelines">Git 代码编写规范</a>中的 <code>Writing Documentation</code> 章节。</p>
<h2 id="编写-commit">编写 commit</h2>
<p>编写 commit 信息也是很重要的一步，这个后续系列文章我会专门说明这一点。</p>
<p>创建 commit 的原则，首先是对逻辑上不同的更改进行不同的提交(make separate commits for logically separate changes)，也就是保持每个commit尽量独立且是最小更改。</p>
<p>每条 commit 需要带上签名，使用 <code>git commit -s</code> ，<code>-s/--signoff</code> 选项会在 commit 尾部加上 <code>Signed-off-by：</code>签名信息。</p>
<p>编写commit message 需要遵循一定规范，如下图：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/image-20210209140518653.png" alt=""></p>
<blockquote>
<p>对于commit message, 官方主要维护者说：A canonical form of our log message starts by explaining the need, and then presents the solution at the end.(一个标准的格式的 commit message 应该在开头描述需求，在结尾展示解决方案。)</p>
<p>commit head 部分不超过 50 个字符<br>
commit body 部分不超过 76 个字符</p>
</blockquote>
<h2 id="向社区提交代码">向社区提交代码</h2>
<p>首先有以下几点需要注意：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">Git 仓库主要有 5 个分支，</label><code>master</code>, <code>maint</code>, <code>seen</code>, <code>next</code>, <code>todo</code>。其中：</p>
</li>
</ul>
<blockquote>
<p><code>seen</code> 是观察分支，向官方提交一般补丁，初步被接受后还需先进入观察期，即合并到seen 分支，此时还要继续接受别人的代码检视，可能会继续修改。</p>
<p><code>next</code> 是预备分支，当 <code>seen</code> 上准备好了后，进入 <code>next</code> 分支，接受更多更广泛的测试，保证新补丁不会引发其它 issue。</p>
<p><code>master</code> 是稳定分支， 在 <code>next</code> 分支上的补丁通过各种测试后，就可以进入稳定分支。</p>
<p><code>maint</code> 是维护分支，bugfix 一般在这个分支上进行(也可以在 master 分支上进行)</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">向社区发送邮件至少需要以下邮件地址：</label></p>
</li>
</ul>
<blockquote>
<ol>
<li class="lvl-3">
<p>主送官方邮件列表(必须)： <a href="mailto:git@vger.kernel.org">git@vger.kernel.org</a>。</p>
</li>
<li class="lvl-3">
<p>抄送代码相关人。比如你的补丁修改了某个文件的某行代码，通过 git-blame 知道这行代码之前的修改者，那么最好也要抄送给这个人，因为他应该比你更熟悉这行代码。</p>
</li>
<li class="lvl-3">
<p>抄送现在主要维护者: <a href="mailto:gitster@pobox.com">gitster@pobox.com</a></p>
</li>
</ol>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2">Git 社区交流都是用</label><strong>纯文本邮件</strong>方式，邮件回复有很多种方式，常见的有 top-posting, bottom-posting, interleaved-style(也叫inline-style)。邮件回复方式详情见 <a href="https://en.wikipedia.org/wiki/Posting_style#Interleaved_style">Posting_style Wiki</a></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">Git 官方社区推荐用 inline-style 回复邮件。</label></p>
</li>
</ul>
<p>向官方提交代码的方式主要有两种:</p>
<p>一. 通过 Git 命令行：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>git format-patch 制作补丁包；</p>
</li>
<li class="lvl-3">
<p>git send-email 发送邮件到官方社区。</p>
</li>
</ol>
</blockquote>
<p>二. 通过 <a href="https://gitgitgadget.github.io/">GitGitGadget</a>：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>使用Github的PR工作流，向 <a href="https://github.com/gitgitgadget/git">GitGitGadget 的 Github 仓库</a> 提交 PR；</p>
</li>
<li class="lvl-3">
<p>找人邀请自己，让别人在 PR 评论区发送 /allow(仅针对第一次提交PR的用户)；</p>
</li>
<li class="lvl-3">
<p>Github CI 通过后，发送 /submit 触发脚本，自动发送格式化的邮件到官方社区。</p>
</li>
</ol>
</blockquote>
<p>通过命令发送邮件向社区提交代码的方式遵循的是比较古老的 <code>mailing list</code>(邮件列表)工作流程，对于现在习惯了直接在网页上提交 <code>PR/MR</code> 的用户来说，邮件列表的方式比较复杂，不建议使用这种方式。但是如果想了解的话，可以参考如下链接：<a href="https://github.com/git-for-windows/git/blob/main/CONTRIBUTING.md#submit-your-patch">Submit Your Patch</a><br>
<code>GitGitGadget</code> 相当于一套自动化程序，实现了 <code>Github PR 工作流</code>，使所有人能够直接在 <code>Github</code> 上通过提交 <code>PR</code> 的方式向 <code>Git</code> 官方提交代码，这极大的简化了原来的 <code>mailing list</code>工作流。所有这里推荐使用这种方式进行提交代码。</p>
<p>如何在 Github 上提交 PR 大部分人应该都会，所有这里就不展开讲了。对于第一次向 Git 仓库提交代码的情况，这里简单说明一下：</p>
<p>当在本地仓库按照前面的方式编写好 commit 后，push 到自己 fork 的仓库后，回到 <a href="https://github.com/gitgitgadget/git"><code>gitgitgadget/git</code></a> 仓库，可以看到：<br>
<img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/20220831183759.png" alt=""></p>
<p>只需要点击绿色按钮，就可以创建 PR 了。</p>
<p><code>GitGitGadget</code> 能够检测到用户是第一次提交 PR ，所以 <strong>gitgitgadget bot</strong> 会自动在 PR 下面发送评论，提示用户该如何操作。这里最重要的一点就是用户(你)需要找一个已经向 Git 成功提交过 PR 的人在你的 PR 评论区发送 <code>/allow</code> 指令，这样你才被正真允许提交 PR。</p>
<p>如果一切顺利，这时候你只需要在 PR 评论区发送 <code>/submit</code> 指令，<code>GitGitGadget</code> 程序会自动将你的 PR 转化为 Git 社区能够接受的格式，并发送到 <a href="https://lore.kernel.org/git/">Git 邮件列表</a> 中。</p>
<h2 id="提交成功！">提交成功！</h2>
<p><code>/submit</code> 指令发送成功后，第一次向 Git 社区提交代码就成功啦！但是，这只是成功的第一步，后续的代码检视，以及你对检视意见的回应才是重点。这将在下一篇文章中介绍。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Workflow</tag>
      </tags>
  </entry>
  <entry>
    <title>认证(Authentication)和授权(Authorization)</title>
    <url>/posts/3be69b54.html</url>
    <content><![CDATA[<h3 id="什么是认证和授权">什么是认证和授权</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>认证(Authentication)，识别身份</p>
</li>
<li class="lvl-2">
<p>授权(Authorization)，授予被识别的身份是否有权限获取指定资源，或授予其操作权限</p>
</li>
</ul>
<p>认证的双方是访问者(User)、身份信息持有者(<strong>IdP</strong>/Identity Provider)。</p>
<p>用户持有的唯一标识符(用户名，UUID 等)，密码信息（密码，指纹等）需要与IdP持有的信息匹配才能认证成功。</p>
<p>资源持有者(Source Owner)，控制资源的获取，修改，删除等。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>身份和资源的分离</p>
</li>
</ul>
<p>资源可能是用户自己产生的，也可能是第三方服务器产生的，或者叫做 Service Provider(SP)，也称 Client。</p>
<p>身份和资源的分离即为 <strong>IdP, SP 分离</strong>。</p>
<p>IdP 与 IdP 之前也可以进行资源传递，并授权。这种方式一般称为<strong>联邦授权</strong>。</p>
<br>
<h3 id="LDAP">LDAP</h3>
<p>LDAP(Light Directory Access Protocol)即轻量级目录访问协议，它是一种为<strong>查询</strong>、<strong>浏览</strong>和<strong>搜索</strong>而优化的专业分布式数据库，它呈树状结构组织数据，和<a href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93&amp;spm=1001.2101.3001.7020">关系数据库</a>不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据，所以大多数是用来查询的。LDAP 只是一种协议，可以有多种实现。</p>
<p>一般结构：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/image-20220213014635093.png" alt=""></p>
<p>DIT(Directory Information Tree）目录信息树<br>
dn(Distinguished Name)：一条记录的详细位置，相当于绝对路径(唯一)<br>
rdn(Relative dn) : 相对dn, 相对于相对路径<br>
dc(Domain Component) ：一条记录所属区域 (哪一颗树)<br>
ou(Organization Unit) ：一条记录所属组织 （哪一个分支）<br>
cn/uid(Common Name/user id)：一条记录的名字/ID (哪一个苹果名字)<br>
sn(Surname): 名字前缀(姓)</p>
<p>基本模型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>信息模型，将信息以树状方式组织，基本数据单元是条目(Entry), 条目又由不同属性组成</p>
</li>
<li class="lvl-2">
<p>命名模型，实现一种条目定位方式</p>
</li>
<li class="lvl-2">
<p>功能模型，实现增删改查等功能</p>
</li>
<li class="lvl-2">
<p>安全模型，实现身份认证，安全通道，访问控制</p>
</li>
</ul>
<br>
<h3 id="OAuth2-0">OAuth2.0</h3>
<p><strong>OAuth 2.0</strong> 是一个授权标准协议，主要用于<strong>资源授权</strong>。</p>
<p>前面提到的身份和资源的分离，OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p>
<p>所以，<strong>OAuth 的核心就是向第三方应用颁发令牌</strong>。</p>
<p>根据 OAuth 2.0 协议规范，主要有四个主体：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>授权服务器</strong>(Authorization Server)，负责颁发 Access Token，Authing 是授权服务器。</p>
</li>
<li class="lvl-2">
<p><strong>资源所有者</strong>(Resource Owner)，即<strong>用户</strong>，授权其他人访问他的资源。</p>
</li>
<li class="lvl-2">
<p><strong>调用方</strong>(Client)，即第三方应用。调用方请求获取 Access Token，经过用户授权后，授权服务器为其颁发 Access Token。调用方可以携带 Access Token 到资源服务器访问用户的资源。</p>
</li>
<li class="lvl-2">
<p><strong>资源服务器</strong>(Resouce Server)，存储用户资源。收到 Access Token 后，验证它的被赋予的权限项目，最后返回资源。</p>
</li>
</ul>
<p>这个过程可能还存在其它主体，如浏览器，也称用户代理(User Agent), 服务提供商(Server Provider)等。</p>
<p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0 定义了四种授权方式。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>授权码模式（authorization code）</p>
</li>
<li class="lvl-2">
<p>简化模式（implicit）</p>
</li>
<li class="lvl-2">
<p>密码模式（resource owner password credentials）</p>
</li>
<li class="lvl-2">
<p>客户端模式（client credentials）</p>
</li>
</ul>
<p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与&quot;服务提供商&quot;的认证服务器进行互动。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/auth2.0_code.png" alt=""></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的&quot;重定向URI&quot;（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的&quot;重定向URI&quot;，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
</blockquote>
<br>
<h3 id="OIDC">OIDC</h3>
<p>OIDC(<strong>OpenID Connect</strong> ) 是 <code>OAuth 2.0</code> 协议的超集，能够认证用户并完成资源授权。OIDC的认证和授权分为<strong>四种模式</strong>：授权码模式（Code）、隐式模式（Implicit）、密码模式（Password）、客户端证书模式（Client Credential）</p>
<p>除了 OIDC 协议之外，还存在着许多标准身份协议，例如 SAML 和 CAS。它们的存在意义都是类似的：为了能让素不相识的 SP 和 IdP 进行快速对接，在用户的许可下让 SP 在 IdP 处完成授权，从而访问 IdP 下资源提供者的资源。</p>
<h3 id="参考链接">参考链接</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://www.bbsmax.com/A/RnJWNaBwzq/">理解OAuth 2.0 - 阮一峰的网络日志</a></p>
</li>
<li class="lvl-2">
<p><a href="https://docs.authing.cn/v2/concepts/oidc/oidc-overview.html">OIDC 与 OAuth2.0 综述</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Auth</category>
      </categories>
      <tags>
        <tag>OAuth2.0</tag>
        <tag>LDAP</tag>
        <tag>OIDC</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 炸弹</title>
    <url>/posts/c5ceb3cc.html</url>
    <content><![CDATA[<h4 id="起源">起源</h4>
<p>Git 炸弹因 XML 炸弹(AKA “billion laughs”)而得名，所以要理解 Git 炸弹，我们不妨先从 XML 炸弹说起。</p>
<p>下面是一段 XML 文件示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">lolz</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol</span><span class="string">&quot;laugh out loud&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol2</span><span class="string">&quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol3</span><span class="string">&quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol4</span><span class="string">&quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol5</span><span class="string">&quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol6</span><span class="string">&quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol7</span><span class="string">&quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol8</span><span class="string">&quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol9</span><span class="string">&quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lolz</span>&gt;</span>&amp;lol9;<span class="tag">&lt;/<span class="name">lolz</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从 ENTITY 字段看起，每行 ENTITY 代表一个 XML 实体(entity)元素，一共10个实体元素，除了第一个实体 <code>lol</code> 定义了字符串&quot;laugh out loud&quot;(AKA lol)外, 其余实体都是实体引用，它们每个都引用自上一个实体，且重复10次。</p>
<p>此 XML 文件的文档内容部分仅包含对实体<code>lol9</code>的一个实例的引用。但是，当它被 DOM 或 SAX 解析器解析时，遇到<code>lol9</code>时，它会扩展为 10 个<code>lol8</code>，而每个<code>lol8</code>会扩展为10 个<code>lol7</code>，依此类推。到将所有内容扩展为文本lol时，字符串&quot;laugh out loud&quot;的数量已达100,000,000。如果再增加一个类似结构的实体，或者第一个实体<code>lol</code>被定义为10个&quot;laugh out loud&quot;字符串的话，那么将有<code>10亿</code>个&quot;laugh out loud&quot;，即十亿大笑。</p>
<p>这段文本看似内容不多，占用内存不大，但是在解析过程中内容被指数级展开，会消耗大量内存资源，所以有人利用这个原理进行DOS攻击，使被攻击的机器的内存迅速耗尽，从而停止服务。</p>
<p>以上这种 XML 攻击，被称作 XML 炸弹。</p>
<p>Git 炸弹的原理大致也跟XML炸弹类似，它利用了 Git 的某种特性，使得重复的文本内容深度嵌套。所以接下来再来看一下 Git 炸弹的原理。</p>
<h4 id="Git-炸弹原理">Git 炸弹原理</h4>
<p>我们都知道 Git 的基本数据结构有<code>commit</code>,<code>tag</code>, <code>tree</code>, <code>blob</code>, blob 只存储文件内容，tree 存储文件名称，文件目录结构， commit 与 tag 类似于一种引用(reference),指向 tree。</p>
<p>每中数据都有自己的<code>hash ID</code>, 所以对于<code>blob</code>来说，只要其中的内容是一样的，那么其 ID 就是一样的，不管其内容的文件名，文件路径是否相同。换句话说，Git消除了<code>blob</code>的重复，允许不同的文件(文件名，文件路径不同)使用相同的<code>blob</code>，目的是减少文件内容的重复。对于<code>tree</code>也是类似。</p>
<p>所以有人就利用这个特性制作了一个 Git 仓库, 其结构类似：</p>
<p><img src="https:%5Cfastly.jsdelivr.net%5Cgh%5CCactusinhand%5Cimages_repo%5Cimages%5Cgit_bomb.png" alt="git bomb"></p>
<p>之后，只要运行包含树的遍历操作的 Git 命令，如<code>git status</code>, <code>git checkout</code> 等命令，Git 会先在内存中构造出该仓库的树结构，在这种特殊的仓库中，这个过程会消耗大量内存，因此只要这个仓库的树嵌套足够深，内存就会马上被消耗完，相关进程会被终止。</p>
<p>与XML炸弹类似，只要这种嵌套结构达到10层，或者底层的 blob 有10个，则整个过程展开会有 10 亿条 <code>tree</code>(路径)。</p>
<h4 id="制作">制作</h4>
<p>Git炸弹第一次公开讨论是在 2017 年，Kate 在自己的博客[2]中讨论了制作 Git 炸弹的原理以及制作方法，制作程序是用 Python 写的，见：</p>
<blockquote>
<p><a href="https://kate.io/blog/making-your-own-exploding-git-repos">https://kate.io/blog/making-your-own-exploding-git-repos</a></p>
</blockquote>
<h4 id="如何防止">如何防止</h4>
<p>经过 Github 以及漏洞平台 Hackerone 同意后，Kate 公开了自己在 Github 上自己的 git-bomb仓库[3]，并且在自己的博客中公开讨论了 Git 炸弹的相关信息，之后马上引起了 Git 上游社区的关注，并且马上讨论了可能的修复方案: [4]</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Git上游社区，最终补丁: [5]</p>
</li>
</ul>
<p>Git 官方的修复是将遍历树的过程变得更快，使得对 Git 炸弹仓库做任何操作不至于等待很久。其<code>commit message</code>写到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">You can see this in a pathological case where a commit adds</span><br><span class="line">a very large number of entries, and we limit based on a</span><br><span class="line">broad pathspec. E.g.:</span><br><span class="line"></span><br><span class="line">  perl -e &#x27;</span><br><span class="line">    chomp(my $blob = `git hash-object -w --stdin &lt;/dev/null`);</span><br><span class="line">    for my $a (1..1000) &#123;</span><br><span class="line">      for my $b (1..1000) &#123;</span><br><span class="line">        print &quot;100644 $blob\t$a/$b\n&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x27; | git update-index --index-info</span><br><span class="line">  git commit -qm add</span><br><span class="line"></span><br><span class="line">  git rev-list HEAD -- .</span><br><span class="line"></span><br><span class="line">This case takes about 100ms now, but after this patch only</span><br><span class="line">needs 6ms. That&#x27;s not a huge improvement, but it&#x27;s easy to</span><br><span class="line">get and it protects us against even more pathological cases</span><br><span class="line">(e.g., going from 1 million to 10 million files would take</span><br><span class="line">ten times as long with the current code, but not increase at</span><br><span class="line">all after this patch).</span><br></pre></td></tr></table></figure>
<p><strong>这个修复并没有解决处理这种仓库导致内存消耗过大问题，只对处理过程的消耗时间做了一次优化</strong>。</p>
<h4 id="相关-CVE">相关 CVE</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://ubuntu.com/security/CVE-2017-15298">CVE-2017-15298</a></p>
</li>
</ul>
<h4 id="参考链接">参考链接</h4>
<ol>
<li class="lvl-3">
<p><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2009/november/xml-denial-of-service-attacks-and-defenses">microsoft: xml-denial-of-service-attacks-and-defenses</a></p>
</li>
<li class="lvl-3">
<p><a href="https://kate.io/blog/git-bomb">kate’s blog</a></p>
</li>
<li class="lvl-3">
<p><a href="https://github.com/Katee/git-bomb">kate: original git-bomb repo on Github</a></p>
</li>
<li class="lvl-3">
<p><a href="https://public-inbox.org/git/20171013123521.hop5hrfsyagu7znl@sigill.intra.peff.net/T/#m58c560c18f93476e23110a0656a8d525170d14a2">git upstream discussion</a></p>
</li>
<li class="lvl-3">
<p><a href="https://github.com/Cactusinhand/git/commit/a937b37e766479c8e780b17cce9c4b252fd97e40">git upstream fix</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Xml</tag>
      </tags>
  </entry>
  <entry>
    <title>git bundle 格式及应用</title>
    <url>/posts/32c910d1.html</url>
    <content><![CDATA[<p><code>git-bundle</code> 文件是一种将 <code>git objects</code> 数据(git packfile)与仓库引用 <code>refs</code> 结合在一起的一种数据包格式，通过 <code>objects + refs</code> 就能恢复出一个完整的 <code>git</code> 仓库，因此可以用 <code>git-bundle</code> 文件来备份 <code>git</code> 仓库。</p>
<!--  more -->
<h3 id="格式">格式</h3>
<p><code>git bundle v2</code> 格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bundle    = signature *prerequisite *reference LF pack</span><br><span class="line">signature = <span class="string">&quot;# v2 git bundle&quot;</span> LF</span><br><span class="line"></span><br><span class="line">prerequisite = <span class="string">&quot;-&quot;</span> obj-id SP comment LF</span><br><span class="line">comment      = *CHAR</span><br><span class="line">reference    = obj-id SP refname LF</span><br><span class="line"></span><br><span class="line">pack         = ... ; packfile</span><br></pre></td></tr></table></figure>
<p><code>git bundle v3</code> 格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bundle    = signature *capability *prerequisite *reference LF pack</span><br><span class="line">signature = <span class="string">&quot;# v3 git bundle&quot;</span> LF</span><br><span class="line"></span><br><span class="line">capability   = <span class="string">&quot;@&quot;</span> key [<span class="string">&quot;=&quot;</span> value] LF</span><br><span class="line">prerequisite = <span class="string">&quot;-&quot;</span> obj-id SP comment LF</span><br><span class="line">comment      = *CHAR</span><br><span class="line">reference    = obj-id SP refname LF</span><br><span class="line">key          = 1*(ALPHA / DIGIT / <span class="string">&quot;-&quot;</span>)</span><br><span class="line">value        = *(%01-09 / %0b-FF)</span><br><span class="line"></span><br><span class="line">pack         = ... ; packfile</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：以上均采用 <code>ABNF</code> 标记法</p>
</blockquote>
<p>可以看出：</p>
<p><code>git bundle v2</code> 包含四个部分：</p>
<ol>
<li class="lvl-3">
<p>签名。标识 <code>git bundle</code> 版本</p>
</li>
<li class="lvl-3">
<p>必要依赖。不包含在当前 <code>bundle包</code> 中，但是被 <code>bundle包</code> 中的数据引用到的数据。</p>
</li>
<li class="lvl-3">
<p>引用。当前 <code>bundle包</code> 中包含的引用。</p>
</li>
<li class="lvl-3">
<p><code>pack文件</code>。<code>git packfile</code></p>
</li>
</ol>
<p><code>git bundle</code> <code>v3</code> 仅比 <code>v2</code> 多了一个 <code>capability</code> 部分。</p>
<p>前面提到过 <code>prerequisite</code> 的概念，其格式为 <code>prerequisite = &quot;-&quot; obj-id SP comment LF</code>，所以来看下这个实际是什么意思。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先打包master分支上最近三次提交</span></span><br><span class="line">$ git bundle create recent.bundle master~3..master</span><br><span class="line">Enumerating objects: 13, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (13/13), <span class="keyword">done</span>.</span><br><span class="line">Compressing objects: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">Total 9 (delta 3), reused 0 (delta 0), pack-reused 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再用 git bundle verify 验证一下这个bundle包有没有外部依赖</span></span><br><span class="line">$ git bundle verify recent.bundle</span><br><span class="line">The bundle contains this ref:</span><br><span class="line">0a831168aa94dffaa92f5d73f3e873ef5fd89603 refs/heads/master</span><br><span class="line">The bundle requires this ref:</span><br><span class="line">d5d9b1c95f0012cb7da18deaff6a806f89e48867</span><br><span class="line">recen.bundle is okay</span><br></pre></td></tr></table></figure>
<p>上面的结果很明显：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The bundle requires this ref:</span><br><span class="line">d5d9b1c95f0012cb7da18deaff6a806f89e48867</span><br></pre></td></tr></table></figure>
<p>再打开这个bundle包文件看下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> v2 git bundle</span><br><span class="line">-d5d9b1c95f0012cb7da18deaff6a806f89e48867 demo.tar.gz</span><br><span class="line">0a831168aa94dffaa92f5d73f3e873ef5fd89603 refs/heads/master</span><br></pre></td></tr></table></figure>
<p>第二行的内容 <code>-d5d9b1c95f0012cb7da18deaff6a806f89e48867 demo.tar.gz</code> 即是<code>prerequisite</code></p>
<p>并且符合格式 <code>prerequisite = &quot;-&quot; obj-id SP comment LF</code></p>
<p>我们看一个实际的 <code>git pack</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PACK^@^@^@^B^@^@^@^C&lt;91&gt;^Kx^A^A±^@Nÿtree 212ccb4755ab7c489bee69200388139d7f081e7c</span><br><span class="line">author Li Linchao &lt;lilinchao@oschina.cn&gt; 1646124003 +0800</span><br><span class="line">committer Li Linchao &lt;lilinchao@oschina.cn&gt; 1646124003 +0800</span><br><span class="line"></span><br><span class="line">add aa.txt</span><br><span class="line">©&amp;5A5x^A^A^E^@úÿaaaa</span><br><span class="line">^E]^A&lt;8f&gt;¢^Bx^A^A<span class="string">&quot;^@Ýÿ100644 aa.txt^@]0&lt;8e&gt;^]^F^K^L8&#125;E,ôt^?&lt;89&gt;ì¹&lt;93&gt;XQ£÷^KlK&lt;9a&gt;&lt;93&gt;pÃ^@ò&amp;bL37©&lt;85&gt;(ÐâWa^X</span></span><br><span class="line"><span class="string">~</span></span><br></pre></td></tr></table></figure>
<p>而此时的 <code>git bundle v2</code> 文件如下：</p>
<blockquote>
<p>git bundle create master.bundle master</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># v2 git bundle</span></span><br><span class="line">e0caba68a7281d4ff86693745a1617ffc72c3e7d refs/heads/master</span><br><span class="line"></span><br><span class="line">PACK^@^@^@^B^@^@^@^C&lt;91&gt;^Kx^A^A±^@Nÿtree 212ccb4755ab7c489bee69200388139d7f081e7c</span><br><span class="line">author Li Linchao &lt;lilinchao@oschina.cn&gt; 1646124003 +0800</span><br><span class="line">committer Li Linchao &lt;lilinchao@oschina.cn&gt; 1646124003 +0800</span><br><span class="line"></span><br><span class="line">add aa.txt</span><br><span class="line">©&amp;5A¢^Bx^A^A<span class="string">&quot;^@Ýÿ100644 aa.txt^@]0&lt;8e&gt;^]^F^K^L8&#125;E,ôt^?&lt;89&gt;ì¹&lt;93&gt;XQ£÷^Kl5x^A^A^E^@úÿaaaa</span></span><br><span class="line"><span class="string">^E]^A&lt;8f&gt;,^B&lt;9d&gt;ï&lt;89&gt;DIr^\&lt;87&gt;*&lt;9b&gt;Æû^X¹É&#125;PÖ</span></span><br></pre></td></tr></table></figure>
<p><code>git bundle v3</code> 文件如下:</p>
<blockquote>
<p>git bundle create --version=3 master-v3.bundle master</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># v3 git bundle</span></span><br><span class="line">@object-format=sha1</span><br><span class="line">e0caba68a7281d4ff86693745a1617ffc72c3e7d refs/heads/master</span><br><span class="line"></span><br><span class="line">PACK^@^@^@^B^@^@^@^C&lt;91&gt;^Kx^A^A±^@Nÿtree 212ccb4755ab7c489bee69200388139d7f081e7c</span><br><span class="line">author Li Linchao &lt;lilinchao@oschina.cn&gt; 1646124003 +0800</span><br><span class="line">committer Li Linchao &lt;lilinchao@oschina.cn&gt; 1646124003 +0800</span><br><span class="line"></span><br><span class="line">add aa.txt</span><br><span class="line">©&amp;5A¢^Bx^A^A<span class="string">&quot;^@Ýÿ100644 aa.txt^@]0&lt;8e&gt;^]^F^K^L8&#125;E,ôt^?&lt;89&gt;ì¹&lt;93&gt;XQ£÷^Kl5x^A^A^E^@úÿaaaa</span></span><br><span class="line"><span class="string">^E]^A&lt;8f&gt;,^B&lt;9d&gt;ï&lt;89&gt;DIr^\&lt;87&gt;*&lt;9b&gt;Æû^X¹É&#125;PÖ</span></span><br></pre></td></tr></table></figure>
<h3 id="操作实践">操作实践</h3>
<p>在机器A中的仓库 <code>R1</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git bundle create file.bundle master</span><br><span class="line"><span class="comment"># 做个标记</span></span><br><span class="line">$ git tag -f lastR2bundle master</span><br></pre></td></tr></table></figure>
<p>将 <code>file.bundle</code> 转移到机器B上，克隆仓库 <code>R2</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b master /path/to/file.bundle R2</span><br><span class="line">Cloning into <span class="string">&#x27;R2&#x27;</span>...</span><br><span class="line">Receiving objects: 100% (38/38), 7.97 KiB | 7.97 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (6/6), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>
<p>回到仓库 <code>R1</code>，仓库 <code>R1</code> 有了新的提交。然后继续打包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git bundle create file.bundle lastR2bundle..master</span><br><span class="line"><span class="comment"># 做个标记，下次打包时使用</span></span><br><span class="line">$ git tag -f lastR2bundle master</span><br></pre></td></tr></table></figure>
<p>将 <code>file.bundle</code> 转移到机器 <code>B</code> 上，再到 <code>R2</code> 仓库中进行更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">Receiving objects: 100% (41/41), 8.28 KiB | 8.28 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (7/7), <span class="keyword">done</span>.</span><br><span class="line">From /home/git/test-git/example/repo.bundle</span><br><span class="line">   d4f54d9..6a33e12  master     -&gt; origin/master</span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 还是在cloned-repo中</span></span><br><span class="line">$ git ls-remote</span><br><span class="line">From /path/to/file.bundle</span><br><span class="line">6a33e12f3d7116863a19bf48471c74c597421f8a        HEAD</span><br><span class="line">45eab37d3cb8b5be02a59d3690cb63d3f692f6b9        refs/remotes/origin/master</span><br><span class="line">45eab37d3cb8b5be02a59d3690cb63d3f692f6b9        refs/remotes/origin/HEAD</span><br><span class="line">6a33e12f3d7116863a19bf48471c74c597421f8a        refs/heads/master</span><br></pre></td></tr></table></figure>
<p>以上操作，看起来都跟读取 Git 远程仓库的一样。<br>
<strong>但是不支持写仓库操作，即 <code>git push</code> 操作。</strong></p>
<p>以上操作就完成了仓库的全量备份和增量备份。</p>
<p>还可以用其它形式进行打包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git bundle create mybundle v1.0.0..master</span><br><span class="line">$ git bundle create mybundle --since=10.days master</span><br><span class="line">$ git bundle create mybundle -10 master</span><br></pre></td></tr></table></figure>
<p>只要是 <code>git rev-list</code> 能接受的参数，就可以放在 <code>git bundle create mybundle</code> 后面。比如可以使用 <code>--max-age</code> 选项，实现根据时间戳来进行备份，大致过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```Bash</span><br><span class="line"><span class="comment"># 当前HEAD的时间戳，作为下次备份的起点时间</span></span><br><span class="line">$ git cat-file commit HEAD | sed -n <span class="string">&quot;s/^committer .*&gt; \([0-9]*\) .*/\1/p&quot;</span> </span><br><span class="line">1660809497</span><br><span class="line"></span><br><span class="line"><span class="comment"># --branches 获取refs/heads/下所有相关commits</span></span><br><span class="line"><span class="comment"># --tags 获取refs/tags/下所有相关commits</span></span><br><span class="line"><span class="comment"># --remotes 获取refs/remotes/下所有相关commits</span></span><br><span class="line"><span class="comment"># --all 获取refs/下所有相关commits</span></span><br><span class="line"><span class="comment"># --objects 表示commit所关联的所有对象</span></span><br><span class="line">$ git bundle create latest.bundle  --max-age=1660807920 --all --objects</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取bundle包中的引用信息，可以通过其它选项筛选出部分引用。</span></span><br><span class="line">$ git bundle list-heads latest.bundle &gt; latest.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过git-ls-remote获取bundle包中的所有引用信息。</span></span><br><span class="line">$ git ls-remote latest.bundle &gt; latest.lsremote</span><br></pre></td></tr></table></figure>
<h3 id="应用">应用</h3>
<p>目前 Gitlab 的<a href="https://docs.gitlab.com/ee/user/project/settings/import_export.html">仓库导出、导入功能</a>以及阿里云效 CodeUp 的<a href="https://help.aliyun.com/document_detail/217005.html?spm=a2cl9.codeup_devops2020_goldlog_organization.0.0.3bcb1510bKSmJi">仓库备份</a>功能主要就是利用 Git-bundle 特性对 Git 仓库进行打包。</p>
<h3 id="参考链接">参考链接</h3>
<ol>
<li class="lvl-3">
<p><a href="https://git-scm.com/docs/git-bundle">https://git-scm.com/docs/git-bundle</a></p>
</li>
<li class="lvl-3">
<p><a href="https://git-scm.com/docs/bundle-format">https://git-scm.com/docs/bundle-format</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 内部原理</title>
    <url>/posts/4fad1e06.html</url>
    <content><![CDATA[<p>本文将深入分析 Git 底层的核心数据结构，如 <code>blob</code>, <code>tree</code>, <code>commit</code>, <code>tag</code> 。通过理解底层数据结构，我们就会更容易理解和掌握相关 Git 命令操作。</p>
<span id="more"></span>
<p>普通Git仓库分为：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>工作区(workspace/working copy)</p>
</li>
<li class="lvl-2">
<p>暂存区(stage/index)</p>
</li>
<li class="lvl-2">
<p>仓库区(local repository/objects database)</p>
</li>
</ul>
<p>裸仓就是不包含工作区的仓库，一般服务端的仓库(即远程库)就是裸仓。</p>
<p>仓库名结尾一般使用 <code>.git</code>为了与正常仓库区分，但不是强制。</p>
<p>创建裸仓的方式有两种：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init --bare &lt;bare-repo&gt;</span><br><span class="line">$ git <span class="built_in">clone</span> --bare source-repo &lt;bare-repo&gt;</span><br></pre></td></tr></table></figure>
<p>我们新建一个空的裸仓, 命名为 <code>remote.git</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init --bare remote.git</span><br></pre></td></tr></table></figure>
<p>然后再创建两个副本，后续的实验就是在repo_a, repo_b中进行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> remote.git repo_a</span><br><span class="line">$ git <span class="built_in">clone</span> remote.git repo_b</span><br></pre></td></tr></table></figure>
<p>进入刚克隆的一个仓库 <code>repo_a</code> 中，只有 <code>.git</code> 目录，<code>.git</code> 目录中的所有文件，即是裸仓中的所有文件，但作为一个正常仓库，目前它工作区还是为空。好在我们可以手动创建一些内容。</p>
<h3 id="认识blob-object"><strong>认识blob object</strong></h3>
<p><strong>git hash-object</strong>： 将数据保存到对象数据库中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&#x27;Hello, Git&#x27;</span> &gt; README</span><br><span class="line">$ git hash-object -w README</span><br><span class="line">6fe402b35d6e80a187adc393f36ce10e4fdd259f</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项-n 为了避免echo在输出字符串时自动添加换行符。</p>
<p>选项 <code>-w</code>表示写入，如果不加这个选项，则仅是计算文件的hash值，不会保存。</p>
</blockquote>
<p>这里将内容 <code>Hello, Git</code> 写入文件README，再对该文件运行了 <code>git hash-objects</code> 命令，并返回了一串值。这串值会以某种形式下保存下来。</p>
<p>用 <code>git count-objects</code> 命令得知，此时仓库已经有了第一个对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git count-objects</span><br><span class="line">$ 1 objects, 4 kilobytes</span><br></pre></td></tr></table></figure>
<p>可以通过  <code>tree</code> 命令查看下 <code>.git/objects</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">├── 6f</span><br><span class="line">│   └── e402b35d6e80a187adc393f36ce10e4fdd259f</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br><span class="line"></span><br><span class="line">3 directories, 1 file</span><br></pre></td></tr></table></figure>
<p>我们把 <code>.git/objects</code> 目录称作对象数据库(object database)，新增的对象都会存到这个目录下。</p>
<p>里面还是熟悉的那串数字，我们对Git的认识就从这一串数字开始。</p>
<p><strong>git cat-file</strong> ： 剖析git数据对象</p>
<p>通过 <code>git cat-file</code> 命令查看新生成的对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p 6fe402b35d6e80a187adc393f36ce10e4fdd259f</span><br><span class="line">Hello, Git</span><br></pre></td></tr></table></figure>
<p>顺便还可以看一下对象的类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> cat-file -t 6fe402b35d6e80a187adc393f36ce10e4fdd259f</span><br><span class="line">blob</span><br></pre></td></tr></table></figure>
<p>这里，我们认识到了git对象中的第一种类型<strong>blob object</strong>, 称之为数据对象。</p>
<p>我们创建了一个文件，内容是 <code>Hello, Git</code>,  通过 <code>git hash-object</code>命令将内容写入到 <code>.git/objects</code>目录中，并且返回指向该数据对象的唯一的键，它是一个40-bit的hash值，通过这串值即可寻找出它对应的文件的内容，因此blob数据对象可表示如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/image-20220213174201053.png" alt="image-20220213174201053"></p>
<p>这也是Git的内容可寻址的文件系统(Content-Addressable Filesystem)的含义。</p>
<p>同时我们也知道了Git会将这40-bit的hash值的前2位作为 <code>.git/objects</code>目录下的子目录，后38位作为子目录下的一个文件的文件名。</p>
<p>通过 <code>file</code>命令我们可以知道这是一个zlib压缩文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file .git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f</span><br><span class="line">.git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f: zlib compressed data</span><br></pre></td></tr></table></figure>
<p>既然是被压缩过的，那么里面的内容就是不可读的。</p>
<p>为了查看里面的内容，先安装一个解压缩工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install pigz</span><br></pre></td></tr></table></figure>
<p>然后运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pigz -d &lt; .git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f</span><br><span class="line">blob 10Hello, Git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-d 表示解压</p>
</blockquote>
<p>可以看到在进行hash时，git内部是按照特定格式进行的:</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/image-20220213174240793.png" alt="image-20220213174240793"></p>
<p>切到 <code>repo_b</code>，我们可以手动验证这个过程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -ne <span class="string">&#x27;blob 10\0Hello, Git&#x27;</span> | sha1sum</span><br><span class="line">6fe402b35d6e80a187adc393f36ce10e4fdd259f  -</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项-e 为了让echo能够识别反斜杠转义符（即字符串中的’\0’)</p>
</blockquote>
<p>再次使用 <code>git hash-objects</code> 验证这条数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&#x27;Hello, Git&#x27;</span> | git hash-object --stdin</span><br><span class="line">6fe402b35d6e80a187adc393f36ce10e4fdd259f</span><br></pre></td></tr></table></figure>
<p>结果是一致的，说明 <code>git hash-objects</code> 在生成hash时，是严格按照特定格式进行的。</p>
<p>此时并没有创建 <code>.git/objects/6f</code> 目录，因为没有加 <code>-w</code> 选项，我们可以手动完成。</p>
<p>我们知道Git会对数据使用 zlib 的 deflate 算法进行压缩，我们也手动验证一下：</p>
<p>创建一个目录和文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> .git/objects/6f</span><br><span class="line">$ <span class="built_in">touch</span> .git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f</span><br></pre></td></tr></table></figure>
<p>接着，使用 pigz 工具压缩数据，存放到 <code>e402b35d6e80a187adc393f36ce10e4fdd259f</code> 文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -ne <span class="string">&#x27;blob 10\0Hello, Git&#x27;</span> | pigz -cz &gt; .git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-c 表示输出，-z 表示采用zlib的deflate算法</p>
</blockquote>
<p>此时我们才可以用 <code>git cat-file </code>查看一下里面的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p 6fe402b35d6e80a187adc393f36ce10e4fdd259f</span><br><span class="line">Hello, Git</span><br></pre></td></tr></table></figure>
<p>同样我们可以 <code>解压</code>，看看压缩文件里面的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pigz -d &lt;  .git/objects/6f/e402b35d6e80a187adc393f36ce10e4fdd259f</span><br><span class="line">blob 10Hello, Git</span><br></pre></td></tr></table></figure>
<p>结果是与前面一致的。</p>
<hr>
<p>回到 <code>repo_a</code> 仓库继续实验其它内容。</p>
<p>再对README文件进行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改写文件</span></span><br><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&quot;Hello, Gitee&quot;</span> &gt; README</span><br><span class="line"><span class="comment"># 写入对象数据库</span></span><br><span class="line">$ git hash-object -w README</span><br><span class="line">216ef921a90b782fed1ca37223c3141ed7d5de32</span><br><span class="line"><span class="comment"># 查看内容</span></span><br><span class="line">$ git cat-file -p 216ef921a90b782fed1ca37223c3141ed7d5de32</span><br><span class="line">Hello, Gitee</span><br></pre></td></tr></table></figure>
<p>再次查看一下 <code>.git/object</code>目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">├── 21</span><br><span class="line">│   └── 6ef921a90b782fed1ca37223c3141ed7d5de32</span><br><span class="line">├── 6f</span><br><span class="line">│   └── e402b35d6e80a187adc393f36ce10e4fdd259f</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br><span class="line"></span><br><span class="line">4 directories, 2 files</span><br></pre></td></tr></table></figure>
<p>里面有两个 Git 对象了，它们分别代表 README 的两个版本。</p>
<p>我们写入了 blob 对象，通过 <code>git status</code> 查看工作区状态，可以看到 README 仍是 <code>Untracked files</code> 状态，也就是暂存区还是空的，此时 <code>.git/</code> 目录中还不存在 <code>index</code> 文件。</p>
<p>我们可以先更新一下暂存区，需要用到新的命令：</p>
<p><strong>git update-index</strong>: 将工作区的文件内容更新到 index 区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git update-index --add --cacheinfo 100644 6fe402b35d6e80a187adc393f36ce10e4fdd259f README</span><br></pre></td></tr></table></figure>
<blockquote>
<p>–add 表示加到Index中</p>
<p>–cacheinfo表示是从git数据库.git/object中添加文件</p>
<p>100644表示普通文件</p>
</blockquote>
<p>再次 git status 查看状态，就不一样了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   README    <span class="comment">#version 1 index区</span></span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README    <span class="comment">#version 2 工作区</span></span><br></pre></td></tr></table></figure>
<p>同时我们也可以看到生成了文件 <code>.git/index</code>。</p>
<p>以上过程相当于 <code>git add REAME</code></p>
<p>所以 <code>git add file</code> 就是将工作区的文件内容更新到暂存区。</p>
<hr>
<h3 id="认识tree-object"><strong>认识tree object</strong></h3>
<p>前面认识的 blob 对象只是文件的内容本身，以及它的hash值，并没有涉及到文件名，要保存文件名需要 tree 对象。</p>
<p><strong>git write-tree</strong>:  从当前 index 区创建树对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line">16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c  <span class="comment"># tree 1</span></span><br></pre></td></tr></table></figure>
<p>又生成了一个 hash 值。查看一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t 16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c</span><br><span class="line">100644 blob 6fe402b35d6e80a187adc393f36ce10e4fdd259f    README</span><br></pre></td></tr></table></figure>
<p>内容与之前暂存区的内容一致，说明确实是从暂存区到了数据库。</p>
<p>这样我们也就认识到了 git 对象中的第二种类型 <strong>tree object</strong>，即树对象。</p>
<p>tree 对象不仅可以保存文件名，还可以保存多个文件的内容及其唯一键，而且它还允许嵌套子树，这相当于文件目录。</p>
<p>我们先再建一棵树：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;1.0&#x27;</span> &gt; VERSION</span><br><span class="line">$ git update-index --add VERSION</span><br><span class="line">$ git update-index --add README  <span class="comment"># version 2</span></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   README</span><br><span class="line">        new file:   VERSION   </span><br><span class="line"> </span><br><span class="line">$ git write-tree</span><br><span class="line">33ad99f76f295411d5c198cb58c5c95e5d0b3c91  <span class="comment"># tree 2</span></span><br><span class="line"></span><br><span class="line">$ git cat-file -p 33ad99f76f295411d5c198cb58c5c95e5d0b3c91</span><br><span class="line">100644 blob 216ef921a90b782fed1ca37223c3141ed7d5de32    README</span><br><span class="line">100644 blob d3827e75a5cadb9fe4a27e1cb9b6d192e7323120    VERSION</span><br></pre></td></tr></table></figure>
<p>这个目录树包含两个文件对象。</p>
<p>其实还可以包含子树，我们可以利用 <code>git read-tree</code> 把第一棵树整个读入暂存区，然后再写入Git 的数据库。</p>
<p><strong>git read-tree</strong>: 将树信息读到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一棵树读到index区，并放到bak下面</span></span><br><span class="line">$ git read-tree --prefix=bak 16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c</span><br><span class="line"><span class="comment"># 将当前整个状态写入新的树，放回数据库</span></span><br><span class="line">$ git write-tree</span><br><span class="line">77e9ad8de018dab58d76e0667507378b3cfe4808  <span class="comment"># tree 3</span></span><br></pre></td></tr></table></figure>
<p>但是此时并没有创建正真的 bak 目录，至少在工作区是没有的(<code>ls</code>查看不到)，它目前只存在于暂存区中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   README</span><br><span class="line">        new file:   VERSION</span><br><span class="line">        new file:   bak/README</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        deleted:    bak/README</span><br></pre></td></tr></table></figure>
<p>此时只需要使用 <code>git checkout </code>命令将它从暂存区恢复到工作区就行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- bak/README</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># 此时可以观察到确实有这个目录了</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README  VERSION  bak</span><br></pre></td></tr></table></figure>
<p>同时别忘了 <code>git cat-file</code> 查看新树：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p 77e9ad8de018dab58d76e0667507378b3cfe4808</span><br><span class="line">100644 blob 216ef921a90b782fed1ca37223c3141ed7d5de32    README</span><br><span class="line">100644 blob d3827e75a5cadb9fe4a27e1cb9b6d192e7323120    VERSION</span><br><span class="line">040000 tree 16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c    bak</span><br></pre></td></tr></table></figure>
<blockquote>
<p>100644表示普通文件，040000 表示目录</p>
</blockquote>
<p>用一张图表示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/image-20220213174314167.png" alt="image-20220213174314167"></p>
<h3 id="认识commit-object"><strong>认识commit object</strong></h3>
<p><strong>git commit-tree</strong>： 创建 commit 对象</p>
<p>目前我们有三棵树：<code>16ab2</code>， <code>33ad9</code>， <code>77e9a</code></p>
<p>现在可以根据树来创建 <strong>commit</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;first commit&#x27;</span> | git commit-tree 16ab2</span><br><span class="line">3aa1317953001375c744a8a12f59a37cc1640fdb</span><br><span class="line">$ git <span class="built_in">log</span> 3aa13</span><br><span class="line">commit 3aa1317953001375c744a8a12f59a37cc1640fdb</span><br><span class="line">Author: Li Linchao &lt;lilinchao@oschina.cn&gt;</span><br><span class="line">Date:   Mon Aug 16 16:16:31 2021 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t 3aa1317953001375c744a8a12f59a37cc1640fdb</span><br><span class="line">commit</span><br><span class="line">$ git cat-file -p 3aa1317953001375c744a8a12f59a37cc1640fdb</span><br><span class="line">tree 16ab25f42fdb4563f1acb0ff8b978493bfd2bc1c</span><br><span class="line">author Li Linchao &lt;lilinchao@oschina.cn&gt; 1629101791 +0800</span><br><span class="line">committer Li Linchao &lt;lilinchao@oschina.cn&gt; 1629101791 +0800</span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure>
<p>这个过程相当于 <code>git commit  -m  &quot;message&quot;</code>。</p>
<p>以上就创建了 git 对象中的第三种类型 <strong>commit object</strong>，即提交对象</p>
<p>其它的 commit 时按照 tree 生成的顺序来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;second commit&#x27;</span> | git commit-tree 33ad9 -p 3aa13</span><br><span class="line">2aa80fc99a89a808fc0342972c5a3514d41fa5f7</span><br><span class="line">$ git <span class="built_in">log</span> 2aa8</span><br><span class="line">commit 2aa80fc99a89a808fc0342972c5a3514d41fa5f7</span><br><span class="line">Author: Li Linchao &lt;lilinchao@oschina.cn&gt;</span><br><span class="line">Date:   Mon Aug 16 16:21:42 2021 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit 3aa1317953001375c744a8a12f59a37cc1640fdb</span><br><span class="line">Author: Li Linchao &lt;lilinchao@oschina.cn&gt;</span><br><span class="line">Date:   Mon Aug 16 16:16:31 2021 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line">(END)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;third commit&#x27;</span> | git commit-tree 77e9a -p 2aa80</span><br><span class="line">bdc5642cd9e8a62767710d1d9761b056f91f094c</span><br><span class="line">$ git <span class="built_in">log</span> bdc56</span><br><span class="line">commit bdc5642cd9e8a62767710d1d9761b056f91f094c</span><br><span class="line">Author: Li Linchao &lt;lilinchao@oschina.cn&gt;</span><br><span class="line">Date:   Mon Aug 16 16:23:00 2021 +0800</span><br><span class="line"></span><br><span class="line">    third commit</span><br><span class="line"></span><br><span class="line">commit 2aa80fc99a89a808fc0342972c5a3514d41fa5f7</span><br><span class="line">Author: Li Linchao &lt;lilinchao@oschina.cn&gt;</span><br><span class="line">Date:   Mon Aug 16 16:21:42 2021 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit 3aa1317953001375c744a8a12f59a37cc1640fdb</span><br><span class="line">Author: Li Linchao &lt;lilinchao@oschina.cn&gt;</span><br><span class="line">Date:   Mon Aug 16 16:16:31 2021 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>
<p>不管是数据对象(blob object), 树对象(tree object), 提交对象(commit object)，所有的对象都会放到对象数据库中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">├── 16</span><br><span class="line">│   └── ab25f42fdb4563f1acb0ff8b978493bfd2bc1c</span><br><span class="line">├── 21</span><br><span class="line">│   └── 6ef921a90b782fed1ca37223c3141ed7d5de32</span><br><span class="line">├── 2a</span><br><span class="line">│   └── a80fc99a89a808fc0342972c5a3514d41fa5f7</span><br><span class="line">├── 33</span><br><span class="line">│   └── ad99f76f295411d5c198cb58c5c95e5d0b3c91</span><br><span class="line">├── 3a</span><br><span class="line">│   └── a1317953001375c744a8a12f59a37cc1640fdb</span><br><span class="line">├── 6f</span><br><span class="line">│   └── e402b35d6e80a187adc393f36ce10e4fdd259f</span><br><span class="line">├── 77</span><br><span class="line">│   └── e9ad8de018dab58d76e0667507378b3cfe4808</span><br><span class="line">├── bd</span><br><span class="line">│   └── c5642cd9e8a62767710d1d9761b056f91f094c</span><br><span class="line">├── d3</span><br><span class="line">│   └── 827e75a5cadb9fe4a27e1cb9b6d192e7323120</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br><span class="line"></span><br><span class="line">11 directories, 9 files</span><br></pre></td></tr></table></figure>
<hr>
<p>创建成功 commit 对象后，很快我们就会发现一个问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">fatal: your current branch <span class="string">&#x27;master&#x27;</span> does not have any commits yet</span><br></pre></td></tr></table></figure>
<p>前面查看 log 时指定了 commit ID 才有结果，但是如果不指定 commit，系统就提示当前分支没有 commit，这是怎么回事？我们平时都是没指定也能正常使用对吧。</p>
<p>原因是还有些工作没有完成，这就涉及到Git引用(<code>Git Reference</code>)。</p>
<p>在 <code>local_a</code> 仓库中，目前我们还没有创建任何引用，所以 <code>.git/refs</code> 下面还是空的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find .git/refs</span><br><span class="line">.git/refs</span><br><span class="line">.git/refs/tags</span><br><span class="line">.git/refs/heads</span><br><span class="line">$ find .git/refs -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure>
<p>我们还是继续手动创建。</p>
<p>首先我们需要一个指向当前分支（默认master）最新提交(bdc56)的引用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> bdc5642cd9e8a62767710d1d9761b056f91f094c &gt; .git/refs/heads/master</span><br></pre></td></tr></table></figure>
<p>此时，再次运行 <code>git log</code>，不需要指定 commit ID 就能看到全部提交历史了。</p>
<p>实际上 git 有专门的命令完成引用设置：git-update-ref</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git update-ref refs/heads/master bdc5642cd9e8a62767710d1d9761b056f91f094c</span><br></pre></td></tr></table></figure>
<p>基于引用，于是就有了分支的实现。实际上每个分支都有一个 head 指针，指向该分支的最新提交。</p>
<p>假设我们在第二次提交(<code>2aa80fc99a89a808fc0342972c5a3514d41fa5f7</code>)上切出一个分支，实际上就是加一个引用名，如 <code>dev</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git update-ref refs/heads/dev 2aa80</span><br></pre></td></tr></table></figure>
<p><code>git log</code> 可以看到第二次提交上有个 <code>dev</code> 的标签，运行 <code>git branch</code> 也可以看到有 dev 分支。</p>
<p>通过 <code>git log</code>可以看到有个特殊的指针HEAD，它是指向引用的引用，它永远指向当前分支。</p>
<p>当前分支在 <code>master</code> 分支上，所以HEAD指向 <code>master</code>，当使用 <code>git checkout dev</code> 后可以看到HEAD指向 <code>dev</code>, 表示当前切换到了 <code>dev</code> 分支。</p>
<p>HEAD是一种符号引用(symbolic reference)</p>
<p>git 有个专门的命令用来读取，修改，删除符号引用：<code>git symbolic-ref</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git symbolic-ref HEAD</span><br><span class="line">refs/heads/master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>表示当前分支是master</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git symbolic-ref HEAD refs/heads/dev</span><br></pre></td></tr></table></figure>
<blockquote>
<p>改变HEAD的指向, 也意味着切换分支</p>
</blockquote>
<hr>
<h3 id="认识tag-object"><strong>认识tag object</strong></h3>
<p>其实还有一种比较少用到的 Git 数据对象是 <strong>tag object</strong>，它和 commit 对象有点类似，创建方式是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -a tag-name -m <span class="string">&quot;tag message&quot;</span></span><br></pre></td></tr></table></figure>
<p>比如我们创建一个 <code>v1.0</code> 的 <code>tag</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.0 -m <span class="string">&quot;version 1.0&quot;</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .git/refs/tags/v1.0</span><br><span class="line">05f749dc5667010dbe07ee181b3607143b84b14f</span><br><span class="line">$ git cat-file -t 05f749dc5667010dbe07ee181b3607143b84b14f</span><br><span class="line">tag</span><br><span class="line">$ git cat-file -p 05f749dc5667010dbe07ee181b3607143b84b14f</span><br><span class="line">object bdc5642cd9e8a62767710d1d9761b056f91f094c</span><br><span class="line"><span class="built_in">type</span> commit</span><br><span class="line">tag v1.0</span><br><span class="line">tagger Li Linchao &lt;lilinchao@oschina.cn&gt; 1629103432 +0800</span><br><span class="line"></span><br><span class="line">version 1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ git cat-file -t v1.0</span><br><span class="line">tag</span><br><span class="line"></span><br><span class="line">$ git cat-file -p v1.0</span><br><span class="line">object bdc5642cd9e8a62767710d1d9761b056f91f094c</span><br><span class="line"><span class="built_in">type</span> commit</span><br><span class="line">tag v1.0</span><br><span class="line">tagger Li Linchao &lt;lilinchao@oschina.cn&gt; 1629103432 +0800</span><br><span class="line"></span><br><span class="line">version 1.0</span><br></pre></td></tr></table></figure>
<p><code>git tag</code> 的 hash 值在 <code>.git/refs/tags/v1.0</code> 文件里面。v1.0 是文件名，也是 tag 名称，文件内容是 tag 的 hash 值，它们一一对应，v1.0 就是 <code>db1cc3710e8b284f44286400b61974a8f1e633d4</code> 的指针。</p>
<p>我们可以借助 <code>git-draw</code> 工具生成一张图来说明此时的仓库各个数据之间的关系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ../git-draw -i --hide-index --hide-legend --hide-reflogs --hide-refs --image-filename output.png</span><br></pre></td></tr></table></figure>
<blockquote>
<p>工具地址:  <a href="https://github.com/sensorflo/git-draw">https://github.com/sensorflo/git-draw</a></p>
</blockquote>
<p>或者手动绘制各种数据的关系，如下：<br>
<img src="https://fastly.jsdelivr.net/gh/Cactusinhand/images_repo/images/20220831112729.png" alt=""></p>
<blockquote>
<p><a href="http://assets.processon.com/chart_image/60a12b2fe0b34d34ca5ef5e7.png">http://assets.processon.com/chart_image/60a12b2fe0b34d34ca5ef5e7.png</a></p>
</blockquote>
<h3 id="参考">参考</h3>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1">Git 内部原理 - Git 对象</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%BC%95%E7%94%A8">Git 内部原理 - Git 引用</a></p>
<p><a href="https://morningspace.github.io/tech/inside-git-1/">认识Git对象</a></p>
<p><a href="https://morningspace.github.io/tech/inside-git-3/">认识Git引用</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 Rust 的一些笔记</title>
    <url>/posts/767b1d3c.html</url>
    <content><![CDATA[<p>Rust是一门偏底层的，安全的，高效的开源编程语言。</p>
<span id="more"></span>
<h3 id="工具链">工具链</h3>
<p><code>rustup</code> 是管理<code>Rust</code>版本和相关工具的命令行工具(rust toolchain installer)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>rustup update</code> 更新<code>Rust</code>版本</p>
</li>
<li class="lvl-2">
<p><code>rustup self uninstall</code> 卸载<code>Rust</code>以及<code>rustup</code>本身</p>
</li>
</ul>
<p><code>Rust</code>工具链中包括<code>rustc</code>编译器工具，<code>rustfmt</code>格式化工具，<code>rustdoc</code>文档化工具等。</p>
<p><code>rustc</code>类似于C/C++中的<code>gcc/clang</code></p>
<p><code>Cargo</code> 是 <code>Rust</code> 的构建系统和包管理器。可以进行构建代码、下载依赖库并编译这些库等。</p>
<p><code>cargo new rust-proj</code> 创建一个Rust项目，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo new rust-proj</span><br><span class="line">     Created binary (application) `rust-proj` package</span><br><span class="line">$ tree rust-proj</span><br><span class="line">rust-proj</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br></pre></td></tr></table></figure>
<p><code>Cargo</code>会在 <em>hello_cargo</em> 目录初始化一个 git 仓库，以及一个<code>.gitignore</code>文件。如果你在现有的 git 仓库中运行 <code>cargo new</code>，则不会生成 git 文件；你可以通过使用<code>cargo new --vcs=git</code> 来覆盖此行为。</p>
<p>可以通过 <code>--vcs</code> 参数使 <code>cargo new</code> 切换到其它版本控制系统（<code>VCS</code>），或者不使用 <code>VCS</code>。运行 <code>cargo new --help</code> 参看可用的选项。</p>
<p><code>cargo build</code>构建项目，目标可执行文件在<code>target/debug/</code>下</p>
<p><code>cargo run</code>则是构建项目并运行。</p>
<p><code>cargo check</code> 检查项目代码正确，确保可编译。不会产生可执行文件。</p>
<p><code>cargo build</code>默认构建是debug模式。如果项目一切都OK，可以运行<code>cargo build --release</code>执行发布构建，这会对项目进行一定编译优化，从而使得代码运行得更快，但是相应地，编译时间会更长。</p>
<p><code>cargo doc --open</code> 会生成当前项目中的依赖库(crate)的文档，并转到浏览器可以查询。</p>
<h3 id="Hello-World">Hello, World!</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>println!</code> 调用了一个 Rust 宏（macro）。如果是调用函数，则应输入 <code>println</code>（没有<code>!</code>）。我们将在第十九章详细讨论宏。现在你只需记住，当看到符号 <code>!</code> 的时候，就意味着调用的是宏而不是普通函数，并且宏并不总是遵循与函数相同的规则。</p>
</li>
</ul>
<p><code>cargo new</code>生成的项目中，包含配置文件<code>Cargo.toml</code></p>
<p>文件名: <code>Cargo.toml</code></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.3&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中“0.8.3”指定依赖版本，其语法遵循语义化版本<a href="http://semver.org/">（Semantic Versioning）</a></p>
<p>这里的<code>0.8.3</code> 实际上是 <code>^0.8.3</code> 的简写，它表示 任何不低于 <code>0.8.3</code>， 但是低于 <code>0.9.0</code> 的版本。Cargo将这些版本视作与 <code>0.8.3</code> 版本公有 API 相兼容的版本，这个声明确保你将获得最新的补丁版本，它仍然可以与本章中的代码正常编译。<code>0.9.0</code> 或以上版本不保证拥有接下来示例中使用到的API。</p>
<hr>
<h3 id="一些定义">一些定义</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Rust变量默认是不可改变的（immutable），如果想声明可变变量，需要使用<code>mut</code>关键字。</p>
</li>
<li class="lvl-2">
<p>Rust不允许对常量使用 <code>mut</code>。常量不光默认不能变，它总是不能变。其声明使用<code>const</code>，且必须标注类型。</p>
</li>
<li class="lvl-2">
<p>整型变量分有符号和无符号，如<code>i8</code>表示有符号8位整数，<code>u8</code>表示无符号8位整数，<code>i128</code>表示有符号128位整数。</p>
</li>
<li class="lvl-2">
<p>还有一种整型依赖计算机架构，<code>isize</code>, <code>usize</code>在不同的架构中表示的长度会不同。</p>
</li>
<li class="lvl-2">
<p>整型字面值有十六进制(<code>0xff</code>)，八进制(<code>0o77</code>)，二进制(<code>0b11</code>)，以及十进制(99_999)，单字节字符(仅限<code>u8</code>)</p>
</li>
<li class="lvl-2">
<p>Rust默认数字类型是<code>i32</code></p>
</li>
<li class="lvl-2">
<p>浮点型变量有两种，<code>f32</code>表示单精度浮点小数，<code>f64</code>表示双精度浮点小数。默认是<code>f64</code>。</p>
</li>
<li class="lvl-2">
<p>字符类型（char）用单引号表示，其大小为4个字节，表示了一个Unicode标量值。</p>
</li>
<li class="lvl-2">
<p>复合类型元组(tuple)一旦声明，其长度不变，其中每一个位置都有一个类型的值，类型可以不同。</p>
</li>
<li class="lvl-2">
<p>复合类型数组(array)长度也是固定的，而且其中类型必须相同。</p>
</li>
</ul>
<p><strong>语句(statement)和表达式(expression)</strong></p>
<p>Rust是一门基于表达式的语言。</p>
<p>语句是执行一些操作，但是不返回值的指令。</p>
<p><code>函数定义</code>就是一个语句。</p>
<p>表达式计算并产生一个值，可以赋予其它变量。</p>
<p><code>函数调用</code>是一个表达式，大括号创建的块作用域也是一个表达式。</p>
<p><code>表达式的结尾没有分号，如果结尾加上分号，则变成了语句。</code></p>
<p>数字本身就是一个表达式，所以它可以返回本身的值赋值给其它变量。</p>
<p>栈(stack)中的数据必须占用已知且大小固定的大小。</p>
<p>当数据大小未知，或大小可能变化的时候，需要用堆(heap)。比如使用内存分配器memory allocator分配指定大小的内存，此时该块内存会被标记为已用，并且以指针来表示这块内存。</p>
<p>而将数据放入栈中的过程并不叫做分配内存，因为这个过程并没有新的内存被分配。</p>
<p>堆的指针可以存储在栈上。</p>
<p>入栈比在堆上分配内存要快。</p>
<p>访问堆中的数据比访问栈上的数据要慢，因为访问堆首先要通过指针来访问，而指针在栈上。</p>
<hr>
<h3 id="一些笔记">一些笔记</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义变量用动词let</p>
</li>
<li class="lvl-2">
<p>借鉴Python的元组</p>
</li>
<li class="lvl-2">
<p>借鉴C++的指针</p>
</li>
<li class="lvl-2">
<p>完善的包管理工具cargo</p>
</li>
<li class="lvl-2">
<p>友好的文档管理</p>
</li>
<li class="lvl-2">
<p>使用先进的VCS管理项目</p>
</li>
<li class="lvl-2">
<p>无垃圾回收机制，使用变量所有权管理内存</p>
</li>
<li class="lvl-2">
<p>编译与执行分开，更早的发现错误</p>
</li>
<li class="lvl-2">
<p>浅拷贝与深拷贝，默认不进行数据的深拷贝，深拷贝使用clone方法</p>
</li>
<li class="lvl-2">
<p>移动(move)操作</p>
</li>
<li class="lvl-2">
<p>Copy trait</p>
</li>
<li class="lvl-2">
<p>栈上数据；堆上数据；既在栈上，又在推上(数据指针在栈上，数据内容在堆上)数据</p>
</li>
<li class="lvl-2">
<p>默认行为：默认变量不可变</p>
</li>
<li class="lvl-2">
<p>引用(ref)变量默认也不能修改其引用的值</p>
</li>
<li class="lvl-2">
<p>一个引用的作用域从声明的地方开始一直持续到最后一次使用为止</p>
</li>
<li class="lvl-2">
<p>字符串slice</p>
</li>
</ul>
<hr>
<ul class="lvl-0">
<li class="lvl-2">
<p>Rust可以直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>Rust没有空值(Null)，因为空值会导致很多错误，而是实现了一个枚举变量<code>Option&lt;T&gt;</code>：</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"># 当为<span class="literal">None</span>时，必须显示指定类型&lt;T&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于字符串方法，以下两种方法等效：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;initial contents&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;initial contents&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>
<p>参考链接：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://www.rust-lang.org/zh-CN">rust中文官网</a></p>
</li>
<li class="lvl-2">
<p><a href="https://kaisery.github.io/trpl-zh-cn/">rust book</a></p>
</li>
<li class="lvl-2">
<p><a href="https://book.rust.team/into-rust.html">rust course</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
</search>
